/*globals define, WebGMEGlobal*/
/*jshint browser: true*/

/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Thu May 11 2017 10:42:38 GMT-0700 (PDT).
 */

define([
    // local
    'text!./HFSM.html',
    './Dialog/Dialog',
    './Simulator/Simulator',
    './Simulator/Choice',
    // built-ins
    'js/Constants',
    'js/Utils/GMEConcepts',
    'js/Controls/ContextMenu',
    'js/DragDrop/DropTarget',
    'js/DragDrop/DragConstants',
    'decorators/DocumentDecorator/DiagramDesigner/DocumentEditorDialog',
    // cytoscape
    'bower/cytoscape/dist/cytoscape.min',
    'cytoscape-edgehandles',
    'cytoscape-context-menus',
    'cytoscape-panzoom',
    'bower/cytoscape-cose-bilkent/cytoscape-cose-bilkent',
    // utils
    'bower/mustache.js/mustache.min',
    'bower/blob-util/dist/blob-util.min',
    'text!./style2.css',
    'q',
    // css
    'css!bower/cytoscape-context-menus/cytoscape-context-menus.css',
    'css!bower/cytoscape-panzoom/cytoscape.js-panzoom.css',
    'css!./styles/HFSMVizWidget.css'], function (
        // local
        HFSMHtml,
        Dialog,
        Simulator,
        Choice,
        // built-ins
        CONSTANTS,
        GMEConcepts,
        ContextMenu,
        dropTarget,
        DROP_CONSTANTS,
        DocumentEditorDialog,
        // cytoscape 
        cytoscape,
        cyEdgehandles,
        cyContext,
        cyPanZoom,
        coseBilkent,
        // utils
        mustache,
        blobUtil,
        styleText,
        Q) {
        'use strict';

        //console.log(cytoscape);
        //console.log(cyEdgehandles);
        //console.log(cyContext);
        //console.log(cyPanZoom);
        //console.log(coseBilkent);

        cytoscape.use( cyEdgehandles, _.debounce.bind( _ ), _.throttle.bind( _ ) );
        cytoscape.use( cyContext, $ );
        cytoscape.use( cyPanZoom, $ );
        cytoscape.use( coseBilkent );

        var rootTypes = ['State Machine','Library'];

        var HFSMVizWidget,
            WIDGET_CLASS = 'h-f-s-m-viz';

        var minPanelWidth = 10; // percent

        HFSMVizWidget = function (logger, container, client) {
            this._logger = logger.fork('Widget');

            this._el = container;

            this._client = client;

            // set widget class
            this._el.addClass(WIDGET_CLASS);
            // add html to element
            this._el.append(HFSMHtml);

            // container
            this._containerTag = '#HFSM_VIZ_DIV';
            this._container = this._el.find(this._containerTag).first();

            this._cy_container = this._el.find('#cy');

            this._initialize();
            this._makeDroppable();

            this._logger.debug('ctor finished');
        };

        HFSMVizWidget.prototype._relativeToWindowPos = function( relativePos ) {
            var self = this;

            var windowPos = {
                x: relativePos.x,
                y: relativePos.y
            };

            var splitPos = $(self._container).parents('.panel-base-wh').parent().position();
            var centerPanelPos = $('.ui-layout-pane-center').position();
            // X OFFSET
            windowPos.x += splitPos.left;
            windowPos.x += centerPanelPos.left;

            // Y OFFSET
            windowPos.y += splitPos.top;
            windowPos.y += centerPanelPos.top;            

            return windowPos;
        };

        HFSMVizWidget.prototype._getContainerPosFromEvent = function( e ) {
            var self = this;
            var x = e.pageX,
                y = e.pageY;
            var selector = $(self._el).find(self._containerTag);
            var splitPos = $(self._container).parents('.panel-base-wh').parent().position();
            var centerPanelPos = $('.ui-layout-pane-center').position();
            // X OFFSET
            x -= splitPos.left;
            x -= centerPanelPos.left;

            // Y OFFSET
            y -= splitPos.top;
            y -= centerPanelPos.top;

            return {
                x: x,
                y: y
            };
        };

        HFSMVizWidget.prototype._initialize = function () {
            var width = this._el.width(),
                height = this._el.height(),
                self = this;
            
            // Root Info
            this.HFSMName = '';

            // NODE RELATED DATA
            this.nodes = {};
            this.hiddenNodes = {};
            this.dependencies = {
                'nodes': {},
                'edges': {}
            };
            this.waitingNodes = {};

            // LAYOUT RELATED DATA
            this._handle = this._el.find('#hfsmVizHandle');
            this._left = this._el.find('#hfsmVizLeft');
            this._right = this._el.find('#hfsmVizRight');

            this._left.css('width', '19.5%');
            this._right.css('width', '80%');

            // SIMULATOR
            this._simulator = new Simulator();
            this._simulator.initialize( this._left, this.nodes, this._client );
            this._simulator.onStateChanged( this.showActiveState.bind(this) );
            this._simulator.onAnimateElement( this.animateElement.bind(this) );
            this._simulator.onShowTransitions( this.showTransitions.bind(this) );

            // DRAGGING INFO
            this.isDragging = false;

            this._handle.mousedown(function(e) {
                self.isDragging = true;
                e.preventDefault();
            });
            this._container.mouseup(function() {
                self.isDragging = false;
                self._cy.resize();
            }).mousemove(function(e) {
                if (self.isDragging) {
                    var selector = $(self._el).find(self._containerTag);
                    var mousePosX = self._getContainerPosFromEvent( e ).x;
                    var maxWidth = selector.width();
                    var handlePercent = 0.5;
                    var minX = 0;
                    var maxX = selector.width() + minX;
                    var leftWidth = mousePosX - minX;
                    var leftPercent = Math.max(minPanelWidth, (leftWidth / maxWidth) * 100);
                    var rightPercent = Math.max(minPanelWidth, 100 - leftPercent - handlePercent);
                    leftPercent = 100 - rightPercent - handlePercent;
                    self._left.css('width', leftPercent + '%');
                    self._right.css('width', rightPercent + '%');
                }
            });

            /*
            var DOMURL = window.URL || window.webkitURL || window;
            var img = new Image();
            var svg = new Blob([data], {type: 'image/svg+xml'});
            var url = DOMURL.createObjectURL(svg);
            */

            this._cytoscape_options = {
                container: this._cy_container,
                //style: styleText,
                style: styleText, //+ 'node { background-image: '+url + ';}',
                // interaction options:
                minZoom: 1e-50,
                maxZoom: 1e50,
                zoomingEnabled: true,
                userZoomingEnabled: true,
                panningEnabled: true,
                userPanningEnabled: true,
                boxSelectionEnabled: true,
                selectionType: 'additive',
                touchTapThreshold: 8,
                desktopTapThreshold: 4,
                autolock: false,
                autoungrabify: false,
                autounselectify: false,

                // rendering options:
                headless: false,
                styleEnabled: true,
                hideEdgesOnViewport: false,
                hideLabelsOnViewport: false,
                textureOnViewport: false,
                motionBlur: false,
                motionBlurOpacity: 0.2,
                wheelSensitivity: 1,
                pixelRatio: 'auto',
            };

            var self = this;

            this._layout_options = {
                'name': 'cose-bilkent',
                // Called on `layoutready`
                ready: function () {
                },
                // Called on `layoutstop`
                stop: function () {
                },
                // Whether to fit the network view after when done
                fit: true,
                // Padding on fit
                padding: 10,
                // Whether to enable incremental mode
                randomize: true,
                // Node repulsion (non overlapping) multiplier
                nodeRepulsion: 5500, // 4500
                // Ideal edge (non nested) length
                idealEdgeLength: 100,   // 50
                // Divisor to compute edge forces
                edgeElasticity: 0.45,
                // Nesting factor (multiplier) to compute ideal edge length for nested edges
                nestingFactor: 0.1,
                // Gravity force (constant)
                gravity: 0.1,  // 0.25
                // Maximum number of iterations to perform
                numIter: 2500,
                // For enabling tiling
                tile: false,   // true
                // Type of layout animation. The option set is {'during', 'end', false}
                animate: 'end',
                // Represents the amount of the vertical space to put between the zero degree members during the tiling operation(can also be a function)
                tilingPaddingVertical: 10,
                // Represents the amount of the horizontal space to put between the zero degree members during the tiling operation(can also be a function)
                tilingPaddingHorizontal: 50,
                // Gravity range (constant) for compounds
                gravityRangeCompound: 1.5,
                // Gravity force (constant) for compounds
                gravityCompound: 1.0,
                // Gravity range (constant)
                gravityRange: 3.8
            };
            this._cytoscape_options.layout = self._layout_options;
            this._cy = cytoscape(self._cytoscape_options);

            var edgeHandleIcon = new Image();
            edgeHandleIcon.src = '/assets/DecoratorSVG/svgs/edgeIcon.svg';
            edgeHandleIcon.width = 10;
            edgeHandleIcon.height = 10;

            // the default values of each option are outlined below:
            var edgeHandleDefaults = {
                preview: true, // whether to show added edges preview before releasing selection
                stackOrder: 4, // Controls stack order of edgehandles canvas element by setting it's z-index
                handleSize: 7.5, // the size of the edge handle put on nodes
                handleHitThreshold: 1, // a threshold for hit detection that makes it easier to grab the handle
                handleIcon: edgeHandleIcon,
                handleColor: '#00235b', //  the colour of the handle and the line drawn from it
                handleLineType: 'ghost', // can be 'ghost' for real edge, 'straight' for a straight line, or 'draw' for a draw-as-you-go line
                handleLineWidth: 1, // width of handle line in pixels
                handleOutlineColor: null,//'#ff0000', // the colour of the handle outline
                handleOutlineWidth: 1, // the width of the handle outline in pixels
                handleNodes: function( node ) { //'node', // selector/filter function
                    var desc = self.nodes[node.id()];
                    return self.isValidSource( desc );
                },
                handlePosition: 'right bottom', // sets the position of the handle in the format of "X-AXIS Y-AXIS" such as "left top", "middle top"
                hoverDelay: 150, // time spend over a target node before it is considered a target selection
                cxt: false, // whether cxt events trigger edgehandles (useful on touch)
                enabled: true, // whether to start the plugin in the enabled state
                toggleOffOnLeave: true, // whether an edge is cancelled by leaving a node (true), or whether you need to go over again to cancel (false; allows multiple edges in one pass)
                edgeType: function( sourceNode, targetNode ) {
                    // can return 'flat' for flat edges between nodes or 'node' for intermediate node between them
                    // returning null/undefined means an edge can't be added between the two nodes
                    var srcDesc = self.nodes[sourceNode.id()];
                    var dstDesc = self.nodes[targetNode.id()];
                    var isValid = self.validEdge( srcDesc, dstDesc );
                    if (isValid)
                        return 'flat';
                    else
                        return null;
                },
                loopAllowed: function( node ) {
                    // for the specified node, return whether edges from itself to itself are allowed
                    var desc = self.nodes[node.id()];
                    return self.validEdgeLoop( desc );
                },
                nodeLoopOffset: -50, // offset for edgeType: 'node' loops
                nodeParams: function( sourceNode, targetNode ) {
                    // for edges between the specified source and target
                    // return element object to be passed to cy.add() for intermediary node
                    return {};
                },
                edgeParams: function( sourceNode, targetNode, i ) {
                    // for edges between the specified source and target
                    // return element object to be passed to cy.add() for edge
                    // NB: i indicates edge index in case of edgeType: 'node'
                    return {};
                },
                start: function( sourceNode ) {
                    // fired when edgehandles interaction starts (drag on handle)
                },
                complete: function( sourceNode, targetNodes, addedEntities, position ) {
                    // fired when edgehandles is done and entities are added
                    self.edgeContextMenu( sourceNode, targetNodes, addedEntities, position );
                },
                stop: function( sourceNode ) {
                    // fired when edgehandles interaction is stopped (either complete with added edges or incomplete)
                }, 
                cancel: function( sourceNode, renderedPosition, invalidTarget ){
                    // fired when edgehandles are cancelled (
                    // incomplete - nothing has been added ) -
                    // renderedPosition is where the edgehandle was
                    // released, invalidTarget is
                    
                    // a collection on which the handle was released,
                    // but which for other reasons (loopAllowed |
                    // edgeType) is an invalid target
                }
            };

            // EDGE HANDLES
            this._cy.edgehandles( edgeHandleDefaults );

            var childAvailableSelector = 'node[NodeType = "State"],node[NodeType ="State Machine"],node[NodeType ="Library"]';

            // CONTEXT MENUS
            /*
            self._cy.on('cxttap', 'node, edge', function(e) {
                clear();
                var node = this;
                var id = node.id();
                if (id) {
                    if (self._selectedNodes.indexOf(id) == -1) {
                        self._selectedNodes.push(id);
                        WebGMEGlobal.State.registerActiveSelection(self._selectedNodes.slice(0));
                    }
                }
                highlight( node );
            });
            */
            
            var options = {
                // List of initial menu items
                menuItems: [
                    {
                        id: 'toggleCollapse',
                        content: '(Un-)Show Children',
                        tooltipText: 'Toggle the display of children.',
                        selector: childAvailableSelector,
                        onClickFunction: function ( e ) {
                            //var node = this;
                            var node = e.target;
                            if (node == self._cy) { }
                            else
                                self.toggleShowChildren( node );
                        },
                        coreAsWell: false,
                        hasTrailingDivider: true, // Whether the item will have a trailing divider
                    },
                    {
                        id: 'setActive',
                        content: 'Set Active',
                        tooltipText: 'Set as the active state.',
                        selector: 'node[NodeType = "State"]',
                        coreAsWell: true,
                        onClickFunction: function ( e ) {
                            var node = e.target;
                            if (node == self._cy) { }
                            else {
                                self._simulator.setActiveState( node.id() );
                            }
                        },
                        coreAsWell: false
                    },
                    {
                        id: 'newChild',
                        content: 'Add child...',
                        tooltipText: 'Create a new state, internal transition, etc.',
                        selector: childAvailableSelector,
                        coreAsWell: true,
                        onClickFunction: function ( e ) {
                            var node = e.target;
                            if (node == self._cy) { }
                            else {
                                var dialog = new Dialog();
                                dialog.initialize( self.nodes[ node.id() ], self._client );
                                dialog.show();
                            }
                        },
                        coreAsWell: false
                    },
                    {
                        id: 'Remove',
                        content: 'Remove',
                        tooltipText: 'Remove',
                        selector: 'node, edge', 
                        onClickFunction: function ( e ) { // The function to be executed on click
                            var node = e.target;
                            if (node == self._cy) { }
                            else
                                self.deleteNode( node.id() );
                        },
                        coreAsWell: false // Whether core instance have this item on cxttap
                    },
                    {
                        id: 'DocumentView',
                        content: 'View/Edit Documentation',
                        tooltipText: 'Edit and View the rendered Markdown Documentation',
                        selector: 'node[NodeType = "Documentation"]', 
                        onClickFunction: function ( e ) { // The function to be executed on click
                            var node = e.target;
                            if (node == self._cy) { }
                            else {
                                self.onEditDocumentation(node.id());
                            }
                        },
                        coreAsWell: false // Whether core instance have this item on cxttap
                    },
                    {
                        id: 'reparentSelection',
                        content: 'Move Selected Nodes Here',
                        tooltipText: 'Makes the node that was right clicked that parent of the selected node.',
                        selector: childAvailableSelector,
                        onClickFunction: function ( e ) {
                            var node = e.target;
                            if (node == self._cy) { }
                            else {
                                self._moveNodes( self._selectedNodes, node.id(), self.cyPosToScreenPos(e.position) );
                            }
                        },
                        coreAsWell: false,
                        hasTrailingDivider: true, // Whether the item will have a trailing divider
                    },
                ],
                // css classes that menu items will have
                menuItemClasses: [
                    // add class names to this list
                ],
                // css classes that context menu will have
                contextMenuClasses: [
                    // add class names to this list
                ]
            };
            var ctxMenuInstance = this._cy.contextMenus( options );

            // PAN ZOOM WIDGET:

            // the default values of each option are outlined below:
            var panZoom_defaults = {
                zoomFactor: 0.05, // zoom factor per zoom tick
                zoomDelay: 45, // how many ms between zoom ticks
                minZoom: 0.1, // min zoom level
                maxZoom: 10, // max zoom level
                fitPadding: 50, // padding when fitting
                panSpeed: 10, // how many ms in between pan ticks
                panDistance: 10, // max pan distance per tick
                panDragAreaSize: 75, // the length of the pan drag box in which the vector for panning is calculated (bigger = finer control of pan speed and direction)
                panMinPercentSpeed: 0.25, // the slowest speed we can pan by (as a percent of panSpeed)
                panInactiveArea: 8, // radius of inactive area in pan drag box
                panIndicatorMinOpacity: 0.5, // min opacity of pan indicator (the draggable nib); scales from this to 1.0
                zoomOnly: false, // a minimal version of the ui only with zooming (useful on systems with bad mousewheel resolution)
                fitSelector: undefined, // selector of elements to fit
                animateOnFit: function(){ // whether to animate on fit
                    return false;
                },
                fitAnimationDuration: 1000, // duration of animation on fit

                // icon class names
                sliderHandleIcon: 'fa fa-minus',
                zoomInIcon: 'fa fa-plus',
                zoomOutIcon: 'fa fa-minus',
                resetIcon: 'fa fa-expand'
            };

            self._cy.panzoom( panZoom_defaults );            

            // layout such

            function highlight( node ){
                self.highlight(node);
            }

            function clear(){
                self.clear();
            }

            // USED FOR DRAG ABILITY
            self._hoveredNodeId = null;
            self._cy.on('mouseover', childAvailableSelector, function(e) {
                var node = this;
                self._hoveredNodeId = node.id();
                if (self._isDropping)
                    self.showDropStatus();
                else
                    self.clearDropStatus();
            });
            self._cy.on('mouseout', childAvailableSelector, function(e) {
                self._hoveredNodeId = null;
                if (self._isDropping)
                    self.showDropStatus();
                else
                    self.clearDropStatus();
            });
            self._el.on('mouseout', function(e) {
                self._hoveredNodeId = null;
                self.clearDropStatus();
            });

            // USED FOR NODE SELECTION AND MULTI-SELECTION

            self._selectedNodes = [];
            self._cy.on('select', 'node, edge', function(e){
                var node = this;
                var id = node.id();
                if (id) {
                    if (self._selectedNodes.indexOf(id) == -1) {
                        self._selectedNodes.push(id);
                        WebGMEGlobal.State.registerActiveSelection(self._selectedNodes.slice(0));
                    }
                }
                highlight( node );
            });

            self._cy.on('unselect', 'node, edge', function(e){
                var node = this;
                var id = node.id();
                if (id) {
                    self._selectedNodes = self._selectedNodes.filter(function(n) {
                        return id != n;
                    });
                    //self._selectedNodes = [];
                    WebGMEGlobal.State.registerActiveSelection(self._selectedNodes.slice(0));
                }
                clear();
            });

            // USED FOR KNOWING WHEN NODES ARE MOVED
            self._webGME_to_cy_scale = 1;
            self._grabbedNode = null;
            self._cy.on('grabon', 'node', function(e) {
                var node = this;
                if (node.id()) {
                    self._grabbedNode = node;
                }
            });

            self._cy.on('free', 'node', function(e) {
                self._grabbedNode = null;
            });

            self._debouncedSaveNodePositions = _.debounce(self.saveNodePositions.bind(self), 500);
            self._unsavedNodePositions = {};
            self._cy.on('position', 'node', function(e) {
                var node = this;
                var type = node.data('type');
                var id = node.id();
                if (type && rootTypes.indexOf(type) == -1 && self.nodes[id]) {
                    var pos = self.cyPosToGmePos( node );
                    //console.log(self.nodes[node.id()].position);
                    self.nodes[id].position = pos;
                    self._debouncedSaveNodePositions()
                }
            });

            // USED FOR ZOOMING AFTER INITIALLY LOADING ALL THE NODES (in CreateNode())
            self._debounced_one_time_zoom = _.debounce(_.once(self.onZoomClicked.bind(self)), 250);
        };

        /* * * * * * * * Display Functions  * * * * * * * */

        function download(filename, text) {
            var element = document.createElement('a');
            var imgData = text.split(',')[1]; // after the comma is the actual image data

            blobUtil.base64StringToBlob( imgData.toString() ).then(function(blob) {
                var blobURL = blobUtil.createObjectURL(blob);

                element.setAttribute('href', blobURL);
                element.setAttribute('download', filename);
                element.style.display = 'none';

                document.body.appendChild(element);

                element.click();

                document.body.removeChild(element);
            }).catch(function(err) {
                console.log('Couldnt make blob from image!');
                console.log(err);
            });
        }

        HFSMVizWidget.prototype.onEditDocumentation = function(gmeId) {
            var self = this;
            var documentation = self.nodes[gmeId].documentation;
            var editorDialog = new DocumentEditorDialog();

            editorDialog.initialize(documentation, function (text) {
                try {
                    self._client.setAttribute(gmeId, 'documentation', text, 'updated documentation for ' + gmeId);
                } catch (e) {
                    console.error('Could not save documentation: ');
                    console.error(e);
                }
            });

            editorDialog.show();
        };

        HFSMVizWidget.prototype.onPanningClicked = function() {
            var self = this;
            self._cy.userPanningEnabled(true);
            self._cy.boxSelectionEnabled(false);
            self._cy.autoungrabify(false);
        };

        HFSMVizWidget.prototype.onBoxSelectClicked = function() {
            var self = this;
            self._cy.userPanningEnabled(false);
            self._cy.boxSelectionEnabled(true);
            self._cy.autoungrabify(true);
        };

        HFSMVizWidget.prototype.onZoomClicked = function() {
            var self = this;
            var layoutPadding = 50;
            self._cy.fit( self._cy.elements(), layoutPadding);
            /*
            self._cy.animate({
                fit: {
                    eles: self._cy.elements(),
                    padding: layoutPadding
                },
                duration: layoutDuration
            });
            */
        };

        HFSMVizWidget.prototype._addSplitPanelToolbarBtns = function(toolbarEl) {
            var self = this;

            // BUTTON EVENT HANDLERS

            var printEl = [
                '<span id="print" class="split-panel-toolbar-btn fa fa-print">',
                '</span>',
            ].join('\n');

            var moveEl = [
                '<span id="pan" class="split-panel-toolbar-btn fa fa-arrows">',
                '</span>',
            ].join('\n');

            var selectEl = [
                '<span id="select" class="split-panel-toolbar-btn fa fa-crop">',
                '</span>',
            ].join('\n');

            var zoomEl = [
                '<span id="zoom" class="split-panel-toolbar-btn fa fa-home">',
                '</span>',
            ].join('\n');

            var layoutEl = [
                '<span id="layout" class="split-panel-toolbar-btn fa fa-random">',
                '</span>',
            ].join('\n');

            toolbarEl.append(printEl);
            //toolbarEl.append(moveEl);
            //toolbarEl.append(selectEl);
            toolbarEl.append(zoomEl);
            toolbarEl.append(layoutEl);

            toolbarEl.find('#print').on('click', function(){
                var png = self._cy.png({
                    full: true,
                    scale: 6,
                    bg: 'white'
                });
                download( self.HFSMName + '-HFSM.png', png );
            });

            toolbarEl.find('#pan').on('click', function() {
                self.onPanningClicked();
            });
            
            toolbarEl.find('#select').on('click', function() {
                self.onBoxSelectClicked();
            });
            
            toolbarEl.find('#zoom').on('click', function(){
                self.onZoomClicked();
            });

            toolbarEl.find('#layout').on('click', function(){
                // ask if they really want to randomize the layout
                var choice = new Choice();
                var choices = [
                    'Yes, run cose-bilkent layout.',
                    'No, do not change any positions'
                ];
                choice.initialize( choices, "Really change the layout?" );
                choice.show();
                return choice.waitForChoice()
                    .then(function(choice) {
                        if (choice == choices[0])
                            self.reLayout();
                    });
            });
        };

        HFSMVizWidget.prototype.highlight = function(node) {
            var self = this;
            node.select();
            self._simulator.hideStateInfo();
            self._simulator.displayStateInfo( node.id() );
        };

        HFSMVizWidget.prototype.clear = function() {
            var self = this;
            self._cy.$(':selected').unselect();
            self._simulator.hideStateInfo();
        };

        /* * * * * * * * Transition Selection  * * * * * * * */

        HFSMVizWidget.prototype.showTransitions = function( transitionIDs ) {
            var self = this;
            self.clear();
            self._selectedNodes = [];
            WebGMEGlobal.State.registerActiveSelection(self._selectedNodes.slice(0));
            transitionIDs.map(function(id) {
                self._selectedNodes.push(id);
                // highlight the Transition
                var idTag = id.replace(/\//gm, "\\/");
                var node = self._cy.$('#'+idTag);
                self.highlight( node );
            });
            WebGMEGlobal.State.registerActiveSelection(self._selectedNodes.slice(0));
        };


        /* * * * * * * * Node Position Functions  * * * * * * * */

        HFSMVizWidget.prototype.cyPosition = function(cyNode, pos) {
            if (pos == undefined)
                return cyNode.position();
            else
                cyNode.position(pos);
        };

        HFSMVizWidget.prototype.cyPosToScreenPos = function(pos) {
            var self = this;
            var extent = self._cy.extent(); // returns bounding box of model positions visible
            var width = $(self._cy_container).width();
            var height = $(self._cy_container).height();
            var newPos = {
                x: (pos.x - extent.x1) / extent.w  * width,
                y: (pos.y - extent.y1) / extent.h  * height,
            };
            return newPos;
        };

        HFSMVizWidget.prototype.screenPosToCyPos = function(pos) {
            var self = this;
            var extent = self._cy.extent(); // returns bounding box of model positions visible
            var width = $(self._cy_container).width();
            var height = $(self._cy_container).height();
            var newPos = {
                x: (pos.x / width) * extent.w + extent.x1,
                y: (pos.y / height) * extent.h + extent.y1,
            };
            return newPos;
        };

        HFSMVizWidget.prototype.gmePosToCyPos = function(desc) {
            var self = this;
            var cyPos = desc.position;
            var parentIDTag = desc.parentId.replace(/\//gm, "\\/");
            var cyParent = self._cy.$('#'+parentIDTag);
            if (cyParent) {
                //cyPos.x -= cyParent.width();
                //cyPos.y -= cyParent.height();
            }
            return cyPos;
        };

        HFSMVizWidget.prototype.cyPosToGmePos = function(cyNode) {
            var self = this;
            var gmePos = self.cyPosition( cyNode );
            var cyParent = cyNode.parent();
            if (cyParent) {
                //gmePos.x += cyParent.width();
                //gmePos.y += cyParent.height();
            }
            return gmePos;
        };

        HFSMVizWidget.prototype.needToUpdatePosition = function(pos1, pos2) {
            var dx = Math.abs(pos1.x - pos2.x);
            var dy = Math.abs(pos1.y - pos2.y);
            var dyThresh = 0.01;
            var dxThresh = 0.01;
            return (dy > dyThresh || dx > dxThresh);
        };

        HFSMVizWidget.prototype.saveNodePositions = function() {
            var self = this;
            if (!self.nodes)
                return;

            var keys = Object.keys(self.nodes);

            self._client.startTransaction();

            keys.map(function(k) {
                var id = k;
                if (self.nodes[id] && rootTypes.indexOf(self.nodes[id].type) == -1) {
                    var pos = self.nodes[id].position;
                    //console.log('saving for '+id);
                    //console.log(pos);
                    self._client.setRegistry(id, 'position', pos);
                }
            });

            self._client.completeTransaction();

            self._unsavedNodePositions = {};
        };

        /* * * * * * * * Graph Creation Functions  * * * * * * * */


        HFSMVizWidget.prototype.checkDependencies = function(desc) {
            var self = this;
            // dependencies will always be either parentId (nodes & edges) or connection (edges)
            var deps = [];
            if (desc.parentId && !self.nodes[desc.parentId]) {
                deps.push(desc.parentId);
            }
            if (desc.isConnection) {
                if (!self.nodes[desc.src])
                    deps.push(desc.src);
                if (!self.nodes[desc.dst])
                    deps.push(desc.dst);
            }
            var depsMet = (deps.length == 0);
            if (!depsMet) {
                if (desc.isConnection)
                    self.dependencies.edges[desc.id] = deps;
                else 
                    self.dependencies.nodes[desc.id] = deps;
                self.waitingNodes[desc.id] = desc;
                if (self.nodes[desc.id])
                    delete self.nodes[desc.id];
            }
            return depsMet;
        };

        HFSMVizWidget.prototype.updateDependencies = function() {
            var self = this;
            var nodePaths = Object.keys(self.dependencies.nodes);
            var edgePaths = Object.keys(self.dependencies.edges);
            // create any nodes whose depenencies are fulfilled now
            nodePaths.map(function(nodePath) {
                var depPaths = self.dependencies.nodes[nodePath];
                if (depPaths && depPaths.length > 0) {
                    depPaths = depPaths.filter(function(objPath) { return self.nodes[objPath] == undefined; });
                    if (!depPaths.length) {
                        var desc = self.waitingNodes[nodePath];
                        delete self.waitingNodes[nodePath];
                        delete self.dependencies.nodes[nodePath];
                        self.createNode(desc);
                    }
                    else {
                        self.dependencies.nodes[nodePath] = depPaths;
                    }
                }
                else {
                    delete self.dependencies.nodes[nodePath];
                }
            });
            // Create any edges whose dependencies are fulfilled now
            edgePaths.map(function(edgePath) {
                var depPaths = self.dependencies.edges[edgePath];
                if (depPaths && depPaths.length > 0) {
                    depPaths = depPaths.filter(function(objPath) { return self.nodes[objPath] == undefined; });
                    if (!depPaths.length) {
                        var connDesc = self.waitingNodes[edgePath];
                        delete self.waitingNodes[edgePath];
                        delete self.dependencies.edges[edgePath];
                        self.createEdge(connDesc);
                    }
                    else {
                        self.dependencies.edges[edgePath] = depPaths;
                    }
                }
                else {
                    delete self.dependencies.edges[edgePath];
                }
            });
        };

        HFSMVizWidget.prototype.reLayout = function() {
            var self = this;
            var layout = self._cy.layout(self._layout_options);
            layout.run();
        };

        HFSMVizWidget.prototype.getDescData = function(desc) {
            var self = this;
            var data = {};
            if (desc.isConnection) {
                var from = self.nodes[desc.src];
                var to = self.nodes[desc.dst];
                if (from && to) {
                    data = {
                        id: desc.id,
                        type: desc.type,
                        interaction: desc.type,
                        source: from.id,
                        target: to.id,
                        name: desc.name,
                        // source-label
                        // target-label
                        label: desc.LABEL,
                        Enabled: (desc.Enabled) ? "True" : "False"
                    };
                }
            }
            else {
                data = {
                    id: desc.id,
                    parent: desc.parentId,
                    type: desc.type,
                    NodeType: desc.type,
                    name: desc.name,
                    label: desc.LABEL,
                    isIncomplete: (desc.type == "State" && !desc.isComplete) ? "True" : "False"
                };
            }
            return data;
        };

        HFSMVizWidget.prototype.createEdge = function(desc) {
            var self = this;
            if (desc && desc.src && desc.dst) {
                self.forceShowBranch( desc.parentId );
                var data = self.getDescData(desc);
                if (data) {
                    self._cy.add({
                        group: 'edges',
                        data: data,
                    });
                    self.nodes[desc.id] = desc;
                    self.updateDependencies();
                }
            }
        };

        HFSMVizWidget.prototype.createNode = function(desc) {
            var self = this;
            self.forceShowBranch( desc.parentId );
            var data = self.getDescData(desc);
            var node = {
                group: 'nodes',
                data: data
            };
            var parentCyNode = null;
            var parentPos = null;
            if (desc.parentId) {
                var parentIdTag = desc.parentId.replace(/\//gm, "\\/");
                var parentCyNode = self._cy.$('#'+parentIdTag);
            }
            if (parentCyNode) {
                parentPos = parentCyNode.position();
            }
            
            var pos = null;

            if (parentCyNode && parentPos) {
                pos = self.gmePosToCyPos(desc);
            }

            var n = self._cy.add(node);

            if (pos) {
                self.cyPosition(n, pos);
            }

            self.nodes[desc.id] = desc;
            self.updateDependencies();
            self._debounced_one_time_zoom();
        };
        
        // Adding/Removing/Updating items
        HFSMVizWidget.prototype.addNode = function (desc) {
            var self = this;
            if (self._el && self.nodes && desc) {
                if ( rootTypes.indexOf( desc.type ) > -1 ) {
                    self.HFSMName = desc.name;
                }
                var depsMet = self.checkDependencies(desc);
                // Add node to a table of nodes
                if (desc.isConnection) {  // if this is an edge
                    if (depsMet) { // ready to make edge
                        self.createEdge(desc);
                    }
                }
                else {
                    if (depsMet) { // ready to make node
                        self.createNode(desc);
                    }
                }
                self._simulator.update( );
            }
        };

        HFSMVizWidget.prototype.removeNode = function (gmeId) {
            // TODO: need to have this take into account hidden nodes!
            var self = this;
            if (self._el && self.nodes) {
                var idTag = gmeId.replace(/\//gm, "\\/");
                var desc = self.nodes[gmeId];
                if (desc) {
                    self.forceShowBranch( gmeId );
                    if (!desc.isConnection) {
                        delete self.dependencies.nodes[gmeId];
                        self._cy.$('#'+idTag).neighborhood().forEach(function(ele) {
                            if (ele && ele.isEdge()) {
                                var edgeId = ele.data( 'id' );
                                var edgeDesc = self.nodes[edgeId];
                                self.checkDependencies(edgeDesc);
                            }
                        });
                    }
                    else {
                        delete self.dependencies.edges[gmeId];
                    }
                    self._selectedNodes = self._selectedNodes.filter((id) => {
                        return id != gmeId;
                    });
                    WebGMEGlobal.State.registerActiveSelection(self._selectedNodes.slice(0));
                    delete self.nodes[gmeId];
                    delete self.waitingNodes[gmeId];
                    self._cy.remove("#" + idTag);
                    self.updateDependencies();
                    self._simulator.update( );
                }
            }
        };

        HFSMVizWidget.prototype.updateNode = function (desc) {
            var self = this;
            // TODO: need to have this take into account hidden nodes!
            if (self._el && self.nodes && desc) {
                if ( rootTypes.indexOf( desc.type ) > -1 ) {
                    self.HFSMName = desc.name;
                }
                var oldDesc = this.nodes[desc.id];
                if (oldDesc) {
                    var idTag = desc.id.replace(/\//gm, "\\/");
                    var cyNode = this._cy.$('#'+idTag);
                    if (desc.isConnection) {
                        if (desc.src != oldDesc.src || desc.dst != oldDesc.dst) {
                            this._cy.remove('#' + idTag);
                            self.checkDependencies( desc );
                            self.updateDependencies();
                        }
                        else {
                            cyNode.data( this.getDescData(desc) );
                        }
                    }
                    else {
                        cyNode.data( this.getDescData(desc) );
                        // update position from model
                        if (rootTypes.indexOf(desc.type) == -1) {
                            if (self.needToUpdatePosition( desc.position, oldDesc.position ) ) {
                                var pos = self.gmePosToCyPos( desc );
                                //console.log('updating '+desc.id);
                                //console.log(pos);
                                self.cyPosition(cyNode, pos);
                            }
                        }
                    }
                }
                this.nodes[desc.id] = desc;
                self._simulator.update( );
            }
        };

        /* * * * * * * * Active State Display      * * * * * * * */

        HFSMVizWidget.prototype.animateElement = function( eleId ) {
            var self = this;
            var idTag = eleId.replace(/\//gm, "\\/");
            var eles = self._cy.$('#'+idTag);
            if (eles.length) {
                eles.flashClass("active", 1000);
            }
        };

        HFSMVizWidget.prototype.showActiveState = function( stateId ) {
            var self = this;
            var previousActiveState = self._cy.nodes('[ActiveState]');
            if (previousActiveState.length) {
                var data = previousActiveState.data();
                data.ActiveState = undefined;
                previousActiveState.data( data );
            }
            var idTag = stateId.replace(/\//gm, "\\/");
            var node = self._cy.$('#'+idTag);
            if (node.length) {
                var data = node.data();
                data.ActiveState = true;
                node.data( data );
            }
        };

        /* * * * * * * * Context Menu Functions    * * * * * * * */

        HFSMVizWidget.prototype.createWebGMEContextMenu = function(menuItems, fnCallback, position) {
            var self = this;

            var menu = new ContextMenu({
                items: menuItems,
                callback: function(key) {
                    if (fnCallback)
                        fnCallback(key);
                }
            });

            position = position || {x: 200, y:200};
            menu.show(position);
        };

        HFSMVizWidget.prototype.deleteNode = function( nodeId ) {
            var self = this;
            var edgesTo = self._simulator.getEdgesToNode( nodeId );
            var edgesFrom = self._simulator.getEdgesFromNode( nodeId );

            self._client.startTransaction();

            if (edgesTo) {
                edgesTo.map(function(eid) {
                    self._client.deleteNode( eid, "Removing dependent (dst) transition: " + eid );
                });
            }
            if (edgesFrom) {
                edgesFrom.map(function(eid) {
                    self._client.deleteNode( eid, "Removing dependent (src) transition: " + eid );
                });
            }
            self._client.deleteNode( nodeId, "Removing " + nodeId );

            self._client.completeTransaction();
        };

        HFSMVizWidget.prototype.getHiddenChildren = function( nodeId ) {
            var self = this;
            return self.hiddenNodes[ nodeId ];
        };

        HFSMVizWidget.prototype.hasHiddenChildren = function( nodeId ) {
            var self = this;
            return self.getHiddenChildren( nodeId ) != null;
        };

        HFSMVizWidget.prototype.forceShowBranch = function ( nodeId ) {
            var self = this;
            var node = self.nodes[ nodeId ];
            if ( node && node.parentId ) {
                self.forceShowBranch( node.parentId );
            }
            self.forceShowChildren( nodeId );
        };

        HFSMVizWidget.prototype.forceShowChildren = function ( nodeId ) {
            var self = this;
            var hidden = self.getHiddenChildren( nodeId );
            if (hidden && hidden.nodes && hidden.edges) {
                // currently false, reenable show children
                hidden.nodes.restore();
                hidden.edges.restore();
                delete self.hiddenNodes[nodeId];
            }
        };

        HFSMVizWidget.prototype.toggleShowChildren = function ( node ) {
            var self = this;
            var hidden = self.getHiddenChildren( node.id() );
            if (node.isParent()) {
                // add node background
                node.style({
                    'background-image': 'assets/DecoratorSVG/svgs/stateDiagram.svg',
                    'background-image-opacity': 1.0,
                    'background-width': '90%',
                    'width': 80,
                    'height': 40,
                });
                // currently true, disable show children
                var children, descendants, edges;
                children = node.children();
                if (self.hiddenNodes[node.id()]) {
                    descendants = self.hiddenNodes[node.id()].nodes;
                    edges = self.hiddenNodes[node.id()].edges;
                }
                else {
                    descendants = node.descendants();
                    edges = descendants.connectedEdges();
                }
                self._cy.remove(edges);
                self._cy.remove(descendants);
                self.hiddenNodes[node.id()] = {
                    nodes: descendants,
                    edges: edges,
                };
            }
            else if (hidden && hidden.nodes && hidden.edges) {
                // remove node background
                node.style({
                    'background-image': null,
                    'background-image-opacity': 0,
                    'width': 10,
                    'height': 10,
                });
                // currently false, reenable show children
                hidden.nodes.restore();
                hidden.edges.restore();
                delete self.hiddenNodes[node.id()];
            }
        };

        /* * * * * * * Drag & Drop Related Functions * * * * * * */

        function getValidChildrenTypes( desc, client ) {
            var node = client.getNode( desc.id );
            var validChildTypes = {};

            // figure out what the allowable range is
            var validChildren = node.getValidChildrenTypesDetailed(null, true);
            Object.keys( validChildren ).map(function( metaId ) {
                var child = client.getNode( metaId );
                var childType = child.getAttribute('name');
                var canCreateMore = validChildren[ metaId ];
                if ( canCreateMore &&
                     !child.isAbstract() )
                    validChildTypes[ childType ] = metaId;
            });
            return validChildTypes;
        };

        HFSMVizWidget.prototype._isValidDrop = function (dragInfo, parentId) {
            if (!dragInfo || !parentId)
                return false;
            var self = this;

            // default to true if there are dropped items
            return self._canCreateChildren( dragInfo, parentId );
        };

        HFSMVizWidget.prototype._canCreateChildren = function( dragInfo, parentId ) {
            var self = this;

            var isValid = dragInfo[DROP_CONSTANTS.DRAG_ITEMS].length > 0;

            for (var i=0; i<dragInfo[DROP_CONSTANTS.DRAG_ITEMS].length; i++) {
                var nodeId = dragInfo[DROP_CONSTANTS.DRAG_ITEMS][i];
                if (!self._canCreateChild( nodeId, parentId )) {
                    isValid = false;
                    break;
                }
            }

            return isValid;
        };

        HFSMVizWidget.prototype._canCreateChild = function( nodeId, parentId ) {
            var self = this;
            var canCreate = false;

            var validChildrenTypes,
                nodeObj,
                nodeName,
                metaObj,
                metaName;

            if (parentId && nodeId) {
                validChildrenTypes = getValidChildrenTypes(
                    self.nodes[ parentId ],
                    self._client
                );

                nodeObj = self._client.getNode(nodeId);
                nodeName = nodeObj.getAttribute('name');
                metaObj = self._client.getNode(nodeObj.getMetaTypeId());
                if (metaObj) {
                    metaName = metaObj.getAttribute('name');
                }

                canCreate = validChildrenTypes && metaName &&
                    ( validChildrenTypes[ metaName ] == nodeId ||
                      validChildrenTypes[ metaName ] == nodeObj.getMetaTypeId() );
            }
            return canCreate;
        };

        HFSMVizWidget.prototype._createNode = function( baseId, parentId, childPosition ) {
            var self = this,
                client = self._client;

            if (baseId) {

                client.startTransaction();

                var selector = '#' + parentId.replace(/\//gm, "\\/"),
                    cyNode = self._cy.$(selector),
                    node = client.getNode(baseId);

                self.forceShowChildren( cyNode.id() );

                var pos = self.screenPosToCyPos( childPosition );
                var childCreationParams = {
                    parentId: parentId,
                    baseId: baseId,
                    position: pos
                };

                client.createChild(childCreationParams, 'Creating new child');
                
                client.completeTransaction();
            }
        };

        HFSMVizWidget.prototype._instanceNodes = function( nodeIds, parentId, childPosition ) {
            var self = this,
                client = self._client;

            if (nodeIds.length > 0) {
                client.startTransaction("Creating node instances into " + parentId);

                nodeIds.map(function(nodeId) {
                    var selector = '#' + parentId.replace(/\//gm, "\\/");
                    var cyNode = self._cy.$(selector);
                    var node = client.getNode(nodeId);

                    self.forceShowChildren( cyNode.id() );
                    var pos = self.screenPosToCyPos( childPosition );

                    var childCreationParams = {
                        parentId: parentId,
                        baseId: nodeId,
                        position: pos
                    };
                    client.createChild(childCreationParams);
                });
                
                client.completeTransaction();
            }
        };

        HFSMVizWidget.prototype._copyNodes = function( nodeIds, parentId, childPosition ) {
            var self = this,
                client = self._client;

            if (nodeIds.length > 0) {
                client.startTransaction("Copying Nodes into " + parentId);

                var selector = '#' + parentId.replace(/\//gm, "\\/");
                var cyNode = self._cy.$(selector);

                self.forceShowChildren( cyNode.id() );
                var pos = self.screenPosToCyPos( childPosition );
                var params = {parentId: parentId};

                nodeIds.map(function(nodeId) {
                    params[nodeId] = {
                        'registry': {
                            'position': pos
                        }
                    };
                });
                
                client.copyMoreNodes(params);

                client.completeTransaction();
            }
        };

        HFSMVizWidget.prototype._moveNodes = function( nodeIds, parentId, childPosition ) {
            var self = this,
                client = self._client;

            if (nodeIds.length > 0) {
                if (nodeIds.indexOf(parentId) != -1) {
                    alert('Error!\n'+
                          'Cannot reparent to a node in the selection!');
                    return;
                }
                
                client.startTransaction("Moving nodes into " + parentId);

                var selector = '#' + parentId.replace(/\//gm, "\\/");
                var cyNode = self._cy.$(selector);

                var params = {parentId: parentId};

                self.forceShowChildren( cyNode.id() );
                var pos = self.screenPosToCyPos( childPosition );

                nodeIds.map(function(nodeId) {
                    params[nodeId] = {
                        'registry': {
                            'position': pos
                        }
                    };
                });
                
                client.moveMoreNodes(params);

                client.completeTransaction();
            }
        };

        HFSMVizWidget.prototype.showDropStatus = function () {
            var self = this;
            self.clearDropStatus();
            if (self._isDropping && self._hoveredNodeId && self._dropInfo) {
                var canDrop = self._canCreateChildren( self._dropInfo, self._hoveredNodeId );
                var selector = '#' + self._hoveredNodeId.replace(/\//gm, "\\/");
                var node = self._cy.$( selector );
                if (node.length) {
                    var data = node.data();
                    if (canDrop)
                        data.ValidDrop = true;
                    else
                        data.InvalidDrop = true;
                    node.data( data );
                }
            }
        };

        HFSMVizWidget.prototype.clearDropStatus = function () {
            var self = this;
            var invalidDrops = self._cy.nodes('[InvalidDrop]');
            if (invalidDrops.length) {
                var data = invalidDrops.data();
                data.InvalidDrop = undefined;
                invalidDrops.data( data );
            }
            var validDrops = self._cy.nodes('[ValidDrop]');
            if (validDrops.length) {
                var data = validDrops.data();
                data.ValidDrop = undefined;
                validDrops.data( data );
            }
        };

        HFSMVizWidget.prototype.dropRequiresMenu = function(dragInfo) {
            var self = this,
                client = self._client;
            // default to all items require a drop menu
            var requiresMenu = dragInfo && dragInfo[DROP_CONSTANTS.DRAG_EFFECTS].length > 1;

            return requiresMenu;
        };

        HFSMVizWidget.prototype.handleDrop = function (event, dragInfo) {
            var self = this;

            var menuPos = {x: event.pageX, y: event.pageY},
                childPosition = self._getContainerPosFromEvent(event),
                parentId = self._hoveredNodeId;
            
            childPosition.x -= $(self._left).width();

            if (self._isValidDrop(dragInfo, parentId)) {
                if (self.dropRequiresMenu(dragInfo))
                    self.showDropMenu(menuPos, childPosition, dragInfo);
                else {
                    self._createNode(
                        dragInfo[DROP_CONSTANTS.DRAG_ITEMS],
                        parentId,
                        childPosition
                    );
                }
            } 
        };

        HFSMVizWidget.prototype.showDropMenu = function (menuPosition, childPosition, dragInfo) {
            var self = this,
                parentId = self._hoveredNodeId,
                options = {
                    '0': {
                        name: 'Create Instance',
                        icon: false,
                        fn: function() {
                            self._instanceNodes(
                                dragInfo[DROP_CONSTANTS.DRAG_ITEMS],
                                parentId,
                                childPosition
                            );
                        }
                    },
                    '1': {
                        name: 'Move Here',
                        icon: false,
                        fn: function() {
                            self._moveNodes(
                                dragInfo[DROP_CONSTANTS.DRAG_ITEMS],
                                parentId,
                                childPosition
                            );
                        }
                    },
                    '2': {
                        name: 'Copy Here',
                        icon: false,
                        fn: function() {
                            self._copyNodes(
                                dragInfo[DROP_CONSTANTS.DRAG_ITEMS],
                                parentId,
                                childPosition
                            );
                        }
                    }
                };

            self.createWebGMEContextMenu(options, function(option) {
                if (options[option] && options[option].fn)
                    options[option].fn();
            }, menuPosition);
        };

        HFSMVizWidget.prototype._makeDroppable = function () {
            var self = this,
                desc;
            self._isDropping = false;
            self._right.addClass('drop-area');
            //self._div.append(self.__iconAssignNullPointer);

            dropTarget.makeDroppable(self._right, {
                over: function (event, dragInfo) {
                    self._isDropping = true;
                    self._dropInfo = dragInfo;
                },
                out: function (/*event, dragInfo*/) {
                    self._isDropping = false;
                    self._dropInfo = null;
                },
                drop: function (event, dragInfo) {
                    self.handleDrop(event, dragInfo);
                    self._isDropping = false;
                    self._dropInfo = null;
                }
            });
        };

        /* * * * * * * * Edge Creation Functions   * * * * * * * */

        HFSMVizWidget.prototype.edgeContextMenu = function(cySource, cyTargets, addedEdges, position) {
            var self = this,
                client = self._client;
            // get the valid connections that can be made
            if (!cySource || !cyTargets || !addedEdges) {
            }

            // remove the temporary edges
            addedEdges.map(function(ae) {
                ae.remove();
            });

            var srcId = cySource.id();
            var srcDesc = self.nodes[srcId];
            var dstId = cyTargets[0].id();
            var dstDesc = self.nodes[dstId];

            var parentId = srcDesc.parentId;

            function makeOption(src, dst, connId) {
                var conn = client.getNode(connId);
                return {
                    name: conn.getAttribute('name'),
                    icon: false,
                    fn: function() {
                        self.createNewEdge( parentId, src, dst, connId );
                    }
                }
            }

            var options = {};

            // figure out what kind of connections the parent can have
            var parentNode = client.getNode(parentId);
            GMEConcepts.initialize(client);
            var validConnections = GMEConcepts.getValidConnectionTypesFromSourceInAspect(srcId, parentId, CONSTANTS.ASPECT_ALL);
            
            var options = {};
            var localKey = "" + validConnections.length;
            options[localKey] = {
                name: 'Local Transition',
                icon: false,
                fn: function() {
                    alert('Local Transitions are not supported yet!');
                }
            };

            var i = 0;
            validConnections.map(function(typeId) {
                var key = ""+i;
                i++;
                var option = makeOption( srcId, dstId, typeId);
                options[key] = option;
            });

            var targetPos = self.cyPosition( cyTargets[0] );
            targetPos = position || self.cyPosToScreenPos( targetPos );
            targetPos.x += $(self._left).width();
            targetPos = self._relativeToWindowPos( targetPos );

            self.createWebGMEContextMenu(options, function(option) {
                if (options[option] && options[option].fn)
                    options[option].fn();
            }, targetPos);
        };

        HFSMVizWidget.prototype.createNewEdge = function( parentId, srcId, dstId, edgeMetaId ) {
            var self = this;
            var client = self._client;
            var edgeMetaNode = client.getNode(edgeMetaId);
            var edgeType = edgeMetaNode.getAttribute('name');
            var childCreationParams = {
                parentId: parentId,
                baseId: edgeMetaId,
            };

            client.startTransaction();

            var msg = 'Creating ' + edgeType + ' between ' + srcId + ' and '+dstId;
            var newEdgePath = client.createChild( childCreationParams, msg);
            if (newEdgePath) {
                msg = 'Setting src pointer for ' + newEdgePath + ' to ' + srcId;
                client.setPointer( newEdgePath, 'src', srcId, msg );
                msg = 'Setting dst pointer for ' + newEdgePath + ' to ' + dstId;
                client.setPointer( newEdgePath, 'dst', dstId, msg );
            }

            client.completeTransaction();

            return newEdgePath;
        };

        HFSMVizWidget.prototype.isValidSource = function( desc ) {
            var self = this;
            if (desc.type == 'End State')
                return false;
            else if (desc.type == 'Internal Transition')
                return false;
            else if (desc.type == 'Deep History Pseudostate')
                return false;
            else if (desc.type == 'Shallow History Pseudostate')
                return false;
            else if (desc.type == 'State Machine')
                return false;
            else if (desc.type == 'Documentation')
                return false;
            else if (desc.type == 'Initial') {
                // if initial already has transition, don't allow more
                var initialEdges = self._simulator.getEdgesFromNode( desc.id );
                if (initialEdges.length)
                    return false;
            }
            return true;
        };

        HFSMVizWidget.prototype.validEdgeLoop = function( desc ) {
            var self = this;
            if (desc.type == 'Initial' ||
                desc.type == 'End State' ||
                desc.type == 'Internal Transition' ||
                desc.type == 'Deep History Pseudostate' ||
                desc.type == 'Shallow History Pseudostate' ||
                desc.type == 'Choice Pseudostate')
                return false;
            else
                return true;
        };

        HFSMVizWidget.prototype.validEdge = function( srcDesc, dstDesc ) {
            var self = this;
            var valid = true;
            var srcType = srcDesc.type;
            var dstType = dstDesc.type;
            if (dstType == 'Initial')
                valid = false;
            else if (dstType == 'State Machine')
                valid = false;
            else if (dstType == 'Internal Transition')
                valid = false;
            else if (srcType == 'Internal Transition')
                valid = false;
            else if (srcType == 'End State')
                valid = false;
            else if (srcType == 'Deep History Pseudostate')
                valid = false;
            else if (srcType == 'Shallow History Pseudostate')
                valid = false;
            else if (srcType == 'Initial') {
                if (dstType == 'Deep History Pseudostate' ||
                    dstType == 'Shallow History Pseudostate' ||
                    dstType == 'End State')
                    valid = false;
            }
            return valid;
        };

        /* * * * * * * * Visualizer event handlers * * * * * * * */

        HFSMVizWidget.prototype.onWidgetContainerResize = function (width, height) {
            this._cy.resize();
        };

        HFSMVizWidget.prototype.onNodeClick = function (/*id*/) {
            // This currently changes the active node to the given id and
            // this is overridden in the controller.
        };

        HFSMVizWidget.prototype.onBackgroundDblClick = function () {
        };

        /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
        HFSMVizWidget.prototype.destroy = function () {
            this._el.remove();
            delete this._el;
            delete this.nodes;
            delete this._simulator;
            this._cy.destroy();
        };

        HFSMVizWidget.prototype.onActivate = function () {
        };

        HFSMVizWidget.prototype.onDeactivate = function () {
        };

        return HFSMVizWidget;
    });
