/*globals define, WebGMEGlobal*/
/*jshint browser: true*/

/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Thu May 11 2017 10:42:38 GMT-0700 (PDT).
 */

define([
    'text!./HFSM.html',
    './Dialog/Dialog',
    './Simulator/Simulator',
    './Simulator/Choice',
    'js/DragDrop/DropTarget',
    'js/DragDrop/DragConstants',
    'bower/cytoscape/dist/cytoscape.min',
    'cytoscape-edgehandles',
    'cytoscape-context-menus',
    'bower/cytoscape-cose-bilkent/cytoscape-cose-bilkent',
    'bower/mustache.js/mustache.min',
    'bower/blob-util/dist/blob-util.min',
    'text!./style2.css',
    'q',
    'css!bower/cytoscape-context-menus/cytoscape-context-menus.css',
    'css!./styles/HFSMVizWidget.css'], function (
        HFSMHtml,
        Dialog,
        Simulator,
        Choice,
        dropTarget,
        DROP_CONSTANTS,
        cytoscape,
        edgehandles,
        cyContext,
        coseBilkent,
        mustache,
        blobUtil,
        styleText,
        Q) {
        'use strict';

        cytoscape.use( edgehandles, _.debounce.bind( _ ), _.throttle.bind( _ ) );
        cytoscape.use( cyContext, $ );
        cytoscape.use( coseBilkent );
        //cytoscape.use( cyPopper, Popper );

        var rootTypes = ['State Machine','Library'];

        var HFSMVizWidget,
            WIDGET_CLASS = 'h-f-s-m-viz';

        var minPanelWidth = 10; // percent

        HFSMVizWidget = function (logger, container, client) {
            this._logger = logger.fork('Widget');

            this._el = container;

            this._client = client;

            // set widget class
            this._el.addClass(WIDGET_CLASS);
            // add html to element
            this._el.append(HFSMHtml);

            // container
            this._containerTag = '#HFSM_VIZ_DIV';
            this._container = this._el.find(this._containerTag).first();

            this._cy_container = this._el.find('#cy');

            this._initialize();
            this._makeDroppable();

            this._logger.debug('ctor finished');
        };

        HFSMVizWidget.prototype._getContainerPosFromEvent = function( e ) {
            var self = this;
            var x = e.pageX,
                y = e.pageY;
            var selector = $(self._el).find(self._containerTag);
            var splitPos = $(self._container).parents('.panel-base-wh').parent().position();
            var centerPanelPos = $('.ui-layout-pane-center').position();
            // X OFFSET
            x -= splitPos.left;
            x -= centerPanelPos.left;

            // Y OFFSET
            y -= splitPos.top;
            y -= centerPanelPos.top;

            return {
                x: x,
                y: y
            };
        };

        HFSMVizWidget.prototype._initialize = function () {
            var width = this._el.width(),
                height = this._el.height(),
                self = this;
            
            // Root Info
            this.HFSMName = '';

            // NODE RELATED DATA
            this.nodes = {};
            this.hiddenNodes = {};
            this.dependencies = {
                'nodes': {},
                'edges': {}
            };
            this.waitingNodes = {};
            this.droppedChild = {};

            // LAYOUT RELATED DATA
            this._handle = this._el.find('#hfsmVizHandle');
            this._left = this._el.find('#hfsmVizLeft');
            this._right = this._el.find('#hfsmVizRight');

            this._left.css('width', '19.5%');
            this._right.css('width', '80%');

            // SIMULATOR
            this._simulator = new Simulator();
            this._simulator.initialize( this._left, this.nodes, this._client );
            this._simulator.onStateChanged( this.showActiveState.bind(this) );
            this._simulator.onShowTransitions( this.showTransitions.bind(this) );

            // DRAGGING INFO
            this.isDragging = false;

            this._handle.mousedown(function(e) {
                self.isDragging = true;
                e.preventDefault();
            });
            this._container.mouseup(function() {
                self.isDragging = false;
                self._cy.resize();
            }).mousemove(function(e) {
                if (self.isDragging) {
                    var selector = $(self._el).find(self._containerTag);
                    var mousePosX = self._getContainerPosFromEvent( e ).x;
                    var maxWidth = selector.width();
                    var handlePercent = 0.5;
                    var minX = 0;
                    var maxX = selector.width() + minX;
                    var leftWidth = mousePosX - minX;
                    var leftPercent = Math.max(minPanelWidth, (leftWidth / maxWidth) * 100);
                    var rightPercent = Math.max(minPanelWidth, 100 - leftPercent - handlePercent);
                    leftPercent = 100 - rightPercent - handlePercent;
                    self._left.css('width', leftPercent + '%');
                    self._right.css('width', rightPercent + '%');
                }
            });

            /*
            var DOMURL = window.URL || window.webkitURL || window;
            var img = new Image();
            var svg = new Blob([data], {type: 'image/svg+xml'});
            var url = DOMURL.createObjectURL(svg);
            */

            this._cytoscape_options = {
                container: this._cy_container,
                //style: styleText,
                style: styleText, //+ 'node { background-image: '+url + ';}',
                // interaction options:
                minZoom: 1e-50,
                maxZoom: 1e50,
                zoomingEnabled: true,
                userZoomingEnabled: true,
                panningEnabled: true,
                userPanningEnabled: true,
                boxSelectionEnabled: true,
                selectionType: 'additive',
                touchTapThreshold: 8,
                desktopTapThreshold: 4,
                autolock: false,
                autoungrabify: false,
                autounselectify: false,

                // rendering options:
                headless: false,
                styleEnabled: true,
                hideEdgesOnViewport: false,
                hideLabelsOnViewport: false,
                textureOnViewport: false,
                motionBlur: false,
                motionBlurOpacity: 0.2,
                wheelSensitivity: 1,
                pixelRatio: 'auto',
            };

            var self = this;

            this._layout_options = {
                'name': 'cose-bilkent',
                // Called on `layoutready`
                ready: function () {
                },
                // Called on `layoutstop`
                stop: function () {
                },
                // Whether to fit the network view after when done
                fit: true,
                // Padding on fit
                padding: 10,
                // Whether to enable incremental mode
                randomize: true,
                // Node repulsion (non overlapping) multiplier
                nodeRepulsion: 5500, // 4500
                // Ideal edge (non nested) length
                idealEdgeLength: 100,   // 50
                // Divisor to compute edge forces
                edgeElasticity: 0.45,
                // Nesting factor (multiplier) to compute ideal edge length for nested edges
                nestingFactor: 0.1,
                // Gravity force (constant)
                gravity: 0.1,  // 0.25
                // Maximum number of iterations to perform
                numIter: 2500,
                // For enabling tiling
                tile: false,   // true
                // Type of layout animation. The option set is {'during', 'end', false}
                animate: 'end',
                // Represents the amount of the vertical space to put between the zero degree members during the tiling operation(can also be a function)
                tilingPaddingVertical: 10,
                // Represents the amount of the horizontal space to put between the zero degree members during the tiling operation(can also be a function)
                tilingPaddingHorizontal: 50,
                // Gravity range (constant) for compounds
                gravityRangeCompound: 1.5,
                // Gravity force (constant) for compounds
                gravityCompound: 1.0,
                // Gravity range (constant)
                gravityRange: 3.8
            };
            this._cytoscape_options.layout = self._layout_options;
            this._cy = cytoscape(self._cytoscape_options);

            // the default values of each option are outlined below:
            var defaults = {
                preview: true, // whether to show added edges preview before releasing selection
                stackOrder: 4, // Controls stack order of edgehandles canvas element by setting it's z-index
                handleSize: 5, // the size of the edge handle put on nodes
                handleHitThreshold: 1, // a threshold for hit detection that makes it easier to grab the handle
                handleIcon: false, // an image to put on the handle
                handleColor: '#00235b', //  the colour of the handle and the line drawn from it
                handleLineType: 'ghost', // can be 'ghost' for real edge, 'straight' for a straight line, or 'draw' for a draw-as-you-go line
                handleLineWidth: 1, // width of handle line in pixels
                handleOutlineColor: '#ff0000', // the colour of the handle outline
                handleOutlineWidth: 1, // the width of the handle outline in pixels
                handleNodes: function( node ) { //'node', // selector/filter function
                    var desc = self.nodes[node.id()];
                    return self.isValidSource( desc );
                },
                handlePosition: 'middle top', // sets the position of the handle in the format of "X-AXIS Y-AXIS" such as "left top", "middle top"
                hoverDelay: 150, // time spend over a target node before it is considered a target selection
                cxt: false, // whether cxt events trigger edgehandles (useful on touch)
                enabled: true, // whether to start the plugin in the enabled state
                toggleOffOnLeave: true, // whether an edge is cancelled by leaving a node (true), or whether you need to go over again to cancel (false; allows multiple edges in one pass)
                edgeType: function( sourceNode, targetNode ) {
                    // can return 'flat' for flat edges between nodes or 'node' for intermediate node between them
                    // returning null/undefined means an edge can't be added between the two nodes
                    var srcDesc = self.nodes[sourceNode.id()];
                    var dstDesc = self.nodes[targetNode.id()];
                    var isValid = self.validEdge( srcDesc, dstDesc );
                    if (isValid)
                        return 'flat';
                    else
                        return null;
                },
                loopAllowed: function( node ) {
                    // for the specified node, return whether edges from itself to itself are allowed
                    var desc = self.nodes[node.id()];
                    return self.validEdgeLoop( desc );
                },
                nodeLoopOffset: -50, // offset for edgeType: 'node' loops
                nodeParams: function( sourceNode, targetNode ) {
                    // for edges between the specified source and target
                    // return element object to be passed to cy.add() for intermediary node
                    return {};
                },
                edgeParams: function( sourceNode, targetNode, i ) {
                    // for edges between the specified source and target
                    // return element object to be passed to cy.add() for edge
                    // NB: i indicates edge index in case of edgeType: 'node'
                    return {};
                },
                start: function( sourceNode ) {
                    // fired when edgehandles interaction starts (drag on handle)
                },
                complete: function( sourceNode, targetNodes, addedEntities ) {
                    // fired when edgehandles is done and entities are added
                    if (sourceNode && targetNodes && addedEntities)
                        self.draggedEdge( sourceNode, targetNodes[0], addedEntities[0] );
                    /*
                    // TODO: ASK WHAT KIND OF TRANSITION TO MAKE
                    var choice = new Choice();
                    choice.initialize( ['Local Transition', 'External Transition'], 'What type of transition?');
                    choice.show();
                    return choice.waitForChoice()
                        .then(function(choice) {
                            if (sourceNode && targetNodes && addedEntities)
                                self.draggedEdge( sourceNode, targetNodes[0], addedEntities[0] );
                        });
                    */
                },
                stop: function( sourceNode ) {
                    // fired when edgehandles interaction is stopped (either complete with added edges or incomplete)
                }, 
                cancel: function( sourceNode, renderedPosition, invalidTarget ){
                    // fired when edgehandles are cancelled ( incomplete - nothing has been added ) - renderedPosition is where the edgehandle was released, invalidTarget is
                    // a collection on which the handle was released, but which for other reasons (loopAllowed | edgeType) is an invalid target
                }
            };

            // EDGE HANDLES
            this._cy.edgehandles( defaults );

            var childAvailableSelector = 'node[NodeType = "State"],node[NodeType ="State Machine"]';

            // CONTEXT MENUS
            var options = {
                // List of initial menu items
                menuItems: [
                    {
                        id: 'toggleCollapse',
                        content: '(Un-)Show Children',
                        tooltipText: 'Toggle the display of children.',
                        selector: childAvailableSelector,
                        onClickFunction: function ( e ) {
                            //var node = this;
                            var node = e.target;
                            if (node == self._cy) { }
                            else
                                self.toggleShowChildren( node );
                        },
                        coreAsWell: false,
                        hasTrailingDivider: true, // Whether the item will have a trailing divider
                    },
                    {
                        id: 'setActive',
                        content: 'Set Active',
                        tooltipText: 'Set as the active state.',
                        selector: 'node[NodeType = "State"]',
                        coreAsWell: true,
                        onClickFunction: function ( e ) {
                            var node = e.target;
                            if (node == self._cy) { }
                            else {
                                self._simulator.setActiveState( node.id() );
                            }
                        },
                        coreAsWell: false
                    },
                    {
                        id: 'newChild',
                        content: 'Add child...',
                        tooltipText: 'Create a new state, internal transition, etc.',
                        selector: childAvailableSelector,
                        coreAsWell: true,
                        onClickFunction: function ( e ) {
                            var node = e.target;
                            if (node == self._cy) { }
                            else {
                                var dialog = new Dialog();
                                dialog.initialize( self.nodes[ node.id() ], self._client );
                                dialog.show();
                            }
                        },
                        coreAsWell: false
                    },
                    {
                        id: 'Remove',
                        content: 'Remove',
                        tooltipText: 'Remove',
                        selector: 'node, edge', 
                        onClickFunction: function ( e ) { // The function to be executed on click
                            var node = e.target;
                            if (node == self._cy) { }
                            else
                                self.deleteNode( node.id() );
                        },
                        coreAsWell: false // Whether core instance have this item on cxttap
                    },
                ],
                // css classes that menu items will have
                menuItemClasses: [
                    // add class names to this list
                ],
                // css classes that context menu will have
                contextMenuClasses: [
                    // add class names to this list
                ]
            };
            var ctxMenuInstance = this._cy.contextMenus( options );

            // layout such

            function highlight( node ){
                self.highlight(node);
            }

            function clear(){
                self.clear();
            }

            // USED FOR DRAG ABILITY
            self._hoveredNodeId = null;
            self._cy.on('mouseover', childAvailableSelector, function(e) {
                var node = this;
                self._hoveredNodeId = node.id();
                if (self._isDropping)
                    self.showDropStatus();
                else
                    self.clearDropStatus();
            });
            self._cy.on('mouseout', childAvailableSelector, function(e) {
                self._hoveredNodeId = null;
                if (self._isDropping)
                    self.showDropStatus();
                else
                    self.clearDropStatus();
            });
            self._el.on('mouseout', function(e) {
                self._hoveredNodeId = null;
                self.clearDropStatus();
            });

            // USED FOR NODE SELECTION AND MULTI-SELECTION

            self._selectedNodes = [];
            self._cy.on('select', 'node, edge', function(e){
                var node = this;
                var id = node.id();
                if (id) {
                    if (self._selectedNodes.indexOf(id) == -1) {
                        self._selectedNodes.push(id);
                        WebGMEGlobal.State.registerActiveSelection(self._selectedNodes.slice(0));
                    }
                }
                highlight( node );
            });
            
            self._cy.on('cxttap', 'node, edge', function(e) {
                clear();
                var node = this;
                var id = node.id();
                if (id) {
                    if (self._selectedNodes.indexOf(id) == -1) {
                        self._selectedNodes.push(id);
                        WebGMEGlobal.State.registerActiveSelection(self._selectedNodes.slice(0));
                    }
                }
                highlight( node );
            });

            // USED FOR KNOWING WHEN NODES ARE MOVED
            self._webGME_to_cy_scale = 1;
            self._grabbedNode = null;
            self._cy.on('grabon', 'node', function(e) {
                var node = this;
                if (node.id()) {
                    self._grabbedNode = node;
                }
            });

            self._cy.on('free', 'node', function(e) {
                self._grabbedNode = null;
            });

            self._debouncedSaveNodePositions = _.debounce(self.saveNodePositions.bind(self), 500);
            self._unsavedNodePositions = {};
            self._cy.on('position', 'node', function(e) {
                var node = this;
                if (rootTypes.indexOf(node.data('type')) == -1) {
                    var pos = self.cyPosToGmePos( node );
                    self._unsavedNodePositions[node.id()] = pos;
                    self._debouncedSaveNodePositions()
                }
            });

            // UNSELECT ON NODES AND EDGES

            self._cy.on('unselect', 'node, edge', function(e){
                var node = this;
                var id = node.id();
                if (id) {
                    /*
                    self._selectedNodes = self._selectedNodes.filter(function(n) {
                        return id != n;
                    });
                    */
                    self._selectedNodes = [];
                    WebGMEGlobal.State.registerActiveSelection(self._selectedNodes.slice(0));
                }
                clear();
            });
        };

        /* * * * * * * * Display Functions  * * * * * * * */

        HFSMVizWidget.prototype._addSplitPanelToolbarBtns = function(toolbarEl) {
            var self = this;

            var layoutPadding = 50;
            var layoutDuration = 500;

            // BUTTON EVENT HANDLERS

            var printEl = [
                '<span id="print" class="split-panel-toolbar-btn fa fa-print">',
                '</span>',
            ].join('\n');

            var zoomEl = [
                '<span id="zoom" class="split-panel-toolbar-btn fa fa-home">',
                '</span>',
            ].join('\n');

            var layoutEl = [
                '<span id="re_layout" class="split-panel-toolbar-btn fa fa-random">',
                '</span>',
            ].join('\n');

            toolbarEl.append(printEl);
            toolbarEl.append(zoomEl);
            toolbarEl.append(layoutEl);

            toolbarEl.find('#re_layout').on('click', function(){
                // ask if they really want to randomize the layout
                var choice = new Choice();
                var choices = [
                    'Yes, run cose-bilkent layout.',
                    'No, do not change any positions'
                ];
                choice.initialize( choices, "Really change the layout?" );
                choice.show();
                return choice.waitForChoice()
                    .then(function(choice) {
                        if (choice == choices[0])
                            self.reLayout();
                    });
            });
            
            toolbarEl.find('#zoom').on('click', function(){
                self._cy.animate({
                    fit: {
                        eles: self._cy.elements(),
                        padding: layoutPadding
                    },
                    duration: layoutDuration
                });
            });

            function download(filename, text) {
                var element = document.createElement('a');
                var imgData = text.split(',')[1]; // after the comma is the actual image data

                blobUtil.base64StringToBlob( imgData.toString() ).then(function(blob) {
                    var blobURL = blobUtil.createObjectURL(blob);

                    element.setAttribute('href', blobURL);
                    element.setAttribute('download', filename);
                    element.style.display = 'none';

                    document.body.appendChild(element);

                    element.click();

                    document.body.removeChild(element);
                }).catch(function(err) {
                    console.log('Couldnt make blob from image!');
                    console.log(err);
                });
            }

            toolbarEl.find('#print').on('click', function(){
                var png = self._cy.png({
                    full: true,
                    scale: 6,
                    bg: 'white'
                });
                download( self.HFSMName + '-HFSM.png', png );
            });
        };

        HFSMVizWidget.prototype.highlight = function(node) {
            var self = this;
            node.select();
            self._simulator.hideStateInfo();
            self._simulator.displayStateInfo( node.id() );
        };

        HFSMVizWidget.prototype.clear = function() {
            var self = this;
            self._cy.$(':selected').unselect();
            self._simulator.hideStateInfo();
        };

        /* * * * * * * * Transition Selection  * * * * * * * */

        HFSMVizWidget.prototype.showTransitions = function( transitionIDs ) {
            var self = this;
            self.clear();
            self._selectedNodes = [];
            WebGMEGlobal.State.registerActiveSelection(self._selectedNodes.slice(0));
            transitionIDs.map(function(id) {
                self._selectedNodes.push(id);
                // highlight the Transition
                var idTag = id.replace(/\//gm, "\\/");
                var node = self._cy.$('#'+idTag);
                self.highlight( node );
            });
            WebGMEGlobal.State.registerActiveSelection(self._selectedNodes.slice(0));
        };


        /* * * * * * * * Node Position Functions  * * * * * * * */

        HFSMVizWidget.prototype.getCyTopLeft = function(cyNode) {
            
        };

        HFSMVizWidget.prototype.gmePosToCyPos = function(gmePos) {
            var self = this;
            var cyPos = gmePos;
            /*
            cyPos.x *= self._webGME_to_cy_scale;
            cyPos.y *= self._webGME_to_cy_scale;
            */
            return cyPos;
        };

        HFSMVizWidget.prototype.cyPosToGmePos = function(cyNode) {
            var self = this;
            var cyPos = cyNode.position();
            var gmePos = cyPos;
            /*
            gmePos.x /= self._webGME_to_cy_scale;
            gmePos.y /= self._webGME_to_cy_scale;
            */
            return gmePos;
        };

        HFSMVizWidget.prototype.needToUpdatePosition = function(pos1, pos2) {
            var dx = Math.abs(pos1.x - pos2.x);
            var dy = Math.abs(pos1.y - pos2.y);
            var dyThresh = 0.1;
            var dxThresh = 0.1;
            return (dy > dyThresh || dx > dxThresh);
        };

        HFSMVizWidget.prototype.saveNodePositions = function() {
            var self = this;
            var keys = Object.keys(self._unsavedNodePositions);

            self._client.startTransaction();

            keys.map(function(k) {
                var id = k;
                var pos = self._unsavedNodePositions[id];
                if (self.nodes[id]) {
                    var savedPos = self.nodes[id].position;
                    if (self.needToUpdatePosition(pos, savedPos))
                        self._client.setRegistry(id, 'position', pos);
                }
            });

            self._client.completeTransaction();

            self._unsavedNodePositions = {};
        };

        /* * * * * * * * Graph Creation Functions  * * * * * * * */


        HFSMVizWidget.prototype.checkDependencies = function(desc) {
            var self = this;
            // dependencies will always be either parentId (nodes & edges) or connection (edges)
            var deps = [];
            if (desc.parentId && !self.nodes[desc.parentId]) {
                deps.push(desc.parentId);
            }
            if (desc.isConnection) {
                if (!self.nodes[desc.src])
                    deps.push(desc.src);
                if (!self.nodes[desc.dst])
                    deps.push(desc.dst);
            }
            var depsMet = (deps.length == 0);
            if (!depsMet) {
                if (desc.isConnection)
                    self.dependencies.edges[desc.id] = deps;
                else 
                    self.dependencies.nodes[desc.id] = deps;
                self.waitingNodes[desc.id] = desc;
                if (self.nodes[desc.id])
                    delete self.nodes[desc.id];
            }
            return depsMet;
        };

        HFSMVizWidget.prototype.updateDependencies = function() {
            var self = this;
            var nodePaths = Object.keys(self.dependencies.nodes);
            var edgePaths = Object.keys(self.dependencies.edges);
            // create any nodes whose depenencies are fulfilled now
            nodePaths.map(function(nodePath) {
                var depPaths = self.dependencies.nodes[nodePath];
                if (depPaths && depPaths.length > 0) {
                    depPaths = depPaths.filter(function(objPath) { return self.nodes[objPath] == undefined; });
                    if (!depPaths.length) {
                        var desc = self.waitingNodes[nodePath];
                        delete self.waitingNodes[nodePath];
                        delete self.dependencies.nodes[nodePath];
                        self.createNode(desc);
                    }
                    else {
                        self.dependencies.nodes[nodePath] = depPaths;
                    }
                }
                else {
                    delete self.dependencies.nodes[nodePath];
                }
            });
            // Create any edges whose dependencies are fulfilled now
            edgePaths.map(function(edgePath) {
                var depPaths = self.dependencies.edges[edgePath];
                if (depPaths && depPaths.length > 0) {
                    depPaths = depPaths.filter(function(objPath) { return self.nodes[objPath] == undefined; });
                    if (!depPaths.length) {
                        var connDesc = self.waitingNodes[edgePath];
                        delete self.waitingNodes[edgePath];
                        delete self.dependencies.edges[edgePath];
                        self.createEdge(connDesc);
                    }
                    else {
                        self.dependencies.edges[edgePath] = depPaths;
                    }
                }
                else {
                    delete self.dependencies.edges[edgePath];
                }
            });
        };

        HFSMVizWidget.prototype.reLayout = function() {
            var self = this;
            var layout = self._cy.layout(self._layout_options);
            layout.run();
            //self._cy.nodes().qtip({ content: 'hi', position: { my: 'top center', at: 'bottom center' } })
        };

        HFSMVizWidget.prototype.getDescData = function(desc) {
            var self = this;
            var data = {};
            if (desc.isConnection) {
                var from = self.nodes[desc.src];
                var to = self.nodes[desc.dst];
                if (from && to) {
                    data = {
                        id: desc.id,
                        type: desc.type,
                        interaction: desc.type,
                        source: from.id,
                        target: to.id,
                        name: desc.name,
                        // source-label
                        // target-label
                        label: desc.LABEL
                    };
                }
            }
            else {
                data = {
                    id: desc.id,
                    parent: desc.parentId,
                    type: desc.type,
                    NodeType: desc.type,
                    name: desc.name,
                    label: desc.LABEL,
                    isIncomplete: (desc.type == "State" && !desc.isComplete) ? "True" : "False"
                };
            }
            return data;
        };

        HFSMVizWidget.prototype.createEdge = function(desc) {
            var self = this;
            if (desc && desc.src && desc.dst) {
                self.forceShowBranch( desc.parentId );
                var data = self.getDescData(desc);
                if (data) {
                    self._cy.add({
                        group: 'edges',
                        data: data,
                    });
                    self.nodes[desc.id] = desc;
                    self.updateDependencies();
                }
            }
        };

        HFSMVizWidget.prototype.createNode = function(desc) {
            var self = this;
            self.forceShowBranch( desc.parentId );
            var data = self.getDescData(desc);
            var node = {
                group: 'nodes',
                data: data
            };
            var parentCyNode = null;
            var parentPos = null;
            if (desc.parentId) {
                var parentIdTag = desc.parentId.replace(/\//gm, "\\/");
                var parentCyNode = self._cy.$('#'+parentIdTag);
            }
            if (parentCyNode) {
                parentPos = parentCyNode.position();
            }
            var n = self._cy.add(node);
            if (parentCyNode && parentPos) {
                parentCyNode.position( parentPos );
                //n.position( parentPos );
                var pos = self.gmePosToCyPos( desc.position );
                /*
                var w = parentCyNode.width();
                var h = parentCyNode.height();
                pos.x -= w;
                pos.y -= h;
                */
                //console.log('making node at position: '+pos.x+','+pos.y);
                //n.relativePosition( pos );
                n.position( pos );
            }

            if (self.droppedChild && self.droppedChild.id && self.droppedChild.position) {
                if (self.droppedChild.id == desc.id || self.droppedChild.id == desc.parentId) {
                    n.renderedPosition( self.droppedChild.position );
                    self._clearDroppedChild();
                }
            }

            self.nodes[desc.id] = desc;
            self.updateDependencies();
        };
        
        // Adding/Removing/Updating items
        HFSMVizWidget.prototype.addNode = function (desc) {
            var self = this;
            if (desc) {
                if ( rootTypes.indexOf( desc.type ) > -1 ) {
                    self.HFSMName = desc.name;
                }
                var depsMet = self.checkDependencies(desc);
                // Add node to a table of nodes
                if (desc.isConnection) {  // if this is an edge
                    if (depsMet) { // ready to make edge
                        self.createEdge(desc);
                    }
                }
                else {
                    if (depsMet) { // ready to make node
                        self.createNode(desc);
                    }
                }
                self._simulator.update( );
            }
        };

        HFSMVizWidget.prototype.removeNode = function (gmeId) {
            // TODO: need to have this take into account hidden nodes!
            var self = this;
            var idTag = gmeId.replace(/\//gm, "\\/");
            var desc = self.nodes[gmeId];
            if (desc) {
                self.forceShowBranch( gmeId );
                if (!desc.isConnection) {
                    delete self.dependencies.nodes[gmeId];
                    self._cy.$('#'+idTag).neighborhood().forEach(function(ele) {
                        if (ele && ele.isEdge()) {
                            var edgeId = ele.data( 'id' );
                            var edgeDesc = self.nodes[edgeId];
                            self.checkDependencies(edgeDesc);
                        }
                    });
                }
                else {
                    delete self.dependencies.edges[gmeId];
                }
                self._selectedNodes = self._selectedNodes.filter((id) => {
                    return id != gmeId;
                });
                WebGMEGlobal.State.registerActiveSelection(self._selectedNodes.slice(0));
                delete self.nodes[gmeId];
                delete self.waitingNodes[gmeId];
                self._cy.remove("#" + idTag);
                self.updateDependencies();
                self._simulator.update( );
            }
        };

        HFSMVizWidget.prototype.updateNode = function (desc) {
            var self = this;
            // TODO: need to have this take into account hidden nodes!
            if (desc) {
                if ( rootTypes.indexOf( desc.type ) > -1 ) {
                    self.HFSMName = desc.name;
                }
                var oldDesc = this.nodes[desc.id];
                if (oldDesc) {
                    var idTag = desc.id.replace(/\//gm, "\\/");
                    if (desc.isConnection) {
                        if (desc.src != oldDesc.src || desc.dst != oldDesc.dst) {
                            this._cy.remove('#' + idTag);
                            self.checkDependencies( desc );
                            self.updateDependencies();
                        }
                        else {
                            this._cy.$('#'+idTag).data( this.getDescData(desc) );
                        }
                    }
                    else {
                        this._cy.$('#'+idTag).data( this.getDescData(desc) );
                        // update position from model
                        var pos = self.gmePosToCyPos( desc.position );
                        this._cy.$('#'+idTag).position( pos );
                    }
                }
                this.nodes[desc.id] = desc;
                self._simulator.update( );
            }
        };

        /* * * * * * * * Active State Display      * * * * * * * */

        HFSMVizWidget.prototype.showActiveState = function( stateId ) {
            var self = this;
            var previousActiveState = self._cy.nodes('[ActiveState]');
            if (previousActiveState.length) {
                var data = previousActiveState.data();
                data.ActiveState = undefined;
                previousActiveState.data( data );
            }
            var idTag = stateId.replace(/\//gm, "\\/");
            var node = self._cy.$('#'+idTag);
            if (node.length) {
                var data = node.data();
                data.ActiveState = true;
                node.data( data );
            }
        };

        /* * * * * * * * Context Menu Functions    * * * * * * * */

        HFSMVizWidget.prototype.deleteNode = function( nodeId ) {
            var self = this;
            var edgesTo = self._simulator.getEdgesToNode( nodeId );
            var edgesFrom = self._simulator.getEdgesFromNode( nodeId );

            self._client.startTransaction();

            if (edgesTo) {
                edgesTo.map(function(eid) {
                    self._client.deleteNode( eid, "Removing depenent (dst) transition: " + eid );
                });
            }
            if (edgesFrom) {
                edgesFrom.map(function(eid) {
                    self._client.deleteNode( eid, "Removing depenent (src) transition: " + eid );
                });
            }
            self._client.deleteNode( nodeId, "Removing " + nodeId );

            self._client.completeTransaction();
        };

        HFSMVizWidget.prototype.getHiddenChildren = function( nodeId ) {
            var self = this;
            return self.hiddenNodes[ nodeId ];
        };

        HFSMVizWidget.prototype.hasHiddenChildren = function( nodeId ) {
            var self = this;
            return self.getHiddenChildren( nodeId ) != null;
        };

        HFSMVizWidget.prototype.forceShowBranch = function ( nodeId ) {
            var self = this;
            var node = self.nodes[ nodeId ];
            if ( node && node.parentId ) {
                self.forceShowBranch( node.parentId );
            }
            self.forceShowChildren( nodeId );
        };

        HFSMVizWidget.prototype.forceShowChildren = function ( nodeId ) {
            var self = this;
            var hidden = self.getHiddenChildren( nodeId );
            if (hidden && hidden.nodes && hidden.edges) {
                // currently false, reenable show children
                hidden.nodes.restore();
                hidden.edges.restore();
                delete self.hiddenNodes[nodeId];
            }
        };

        HFSMVizWidget.prototype.toggleShowChildren = function ( node ) {
            var self = this;
            var hidden = self.getHiddenChildren( node.id() );
            if (node.isParent()) {
                // add node background
                node.style({
                    'background-image': 'assets/DecoratorSVG/svgs/stateDiagram.svg',
                    'background-image-opacity': 1.0,
                    'background-width': '90%',
                    'width': 80,
                    'height': 40,
                });
                // currently true, disable show children
                var children, descendants, edges;
                children = node.children();
                if (self.hiddenNodes[node.id()]) {
                    descendants = self.hiddenNodes[node.id()].nodes;
                    edges = self.hiddenNodes[node.id()].edges;
                }
                else {
                    descendants = node.descendants();
                    edges = descendants.connectedEdges();
                }
                self._cy.remove(edges);
                self._cy.remove(descendants);
                self.hiddenNodes[node.id()] = {
                    nodes: descendants,
                    edges: edges,
                };
            }
            else if (hidden && hidden.nodes && hidden.edges) {
                // remove node background
                node.style({
                    'background-image': null,
                    'background-image-opacity': 0,
                    'width': 10,
                    'height': 10,
                });
                // currently false, reenable show children
                hidden.nodes.restore();
                hidden.edges.restore();
                delete self.hiddenNodes[node.id()];
            }
        };

        /* * * * * * * Drag & Drop Related Functions * * * * * * */

        function getValidChildrenTypes( desc, client ) {
            var node = client.getNode( desc.id );
            var validChildTypes = {};

            // figure out what the allowable range is
            var validChildren = node.getValidChildrenTypesDetailed( );
            Object.keys( validChildren ).map(function( metaId ) {
                var child = client.getNode( metaId );
                var childType = child.getAttribute('name');
                var canCreateMore = validChildren[ metaId ];
                if ( canCreateMore &&
                     !child.isAbstract() &&
                     !child.isConnection() )
                    validChildTypes[ childType ] = metaId;
            });

            return validChildTypes;
        };

        HFSMVizWidget.prototype._isValidDrop = function (event, dragInfo) {
            if (!dragInfo)
                return false;
            var self = this;

            var parentId = self._hoveredNodeId;
            var nodeId = null;

            if (dragInfo[DROP_CONSTANTS.DRAG_ITEMS].length === 1) {
                nodeId = dragInfo[DROP_CONSTANTS.DRAG_ITEMS][0];
            }

            return self._canCreateChild( nodeId, parentId );
        };

        HFSMVizWidget.prototype._canCreateChild = function( nodeId, parentId ) {
            var self = this;
            var canCreate = false;

            var validChildrenTypes,
                nodeObj,
                nodeName,
                metaObj,
                metaName;

            if (parentId && nodeId) {
                validChildrenTypes = getValidChildrenTypes(
                    self.nodes[ parentId ],
                    self._client
                );

                nodeObj = self._client.getNode(nodeId);
                nodeName = nodeObj.getAttribute('name');
                metaObj = self._client.getNode(nodeObj.getMetaTypeId());
                if (metaObj) {
                    metaName = metaObj.getAttribute('name');
                }

                canCreate = validChildrenTypes && metaName &&
                    ( validChildrenTypes[ metaName ] == nodeId ||
                      validChildrenTypes[ metaName ] == nodeObj.getMetaTypeId() );
            }
            return canCreate;
        };

        HFSMVizWidget.prototype._clearDroppedChild = function() {
            var self = this;
            self.droppedChild = {};
        };

        HFSMVizWidget.prototype._updateDroppedChild = function( nodeId, event ) {
            var self = this;
            var pos = self._getContainerPosFromEvent(event);
            pos.x -= $(self._left).width();
            self.droppedChild = {
                id: nodeId,
                position: pos
            };
        };

        HFSMVizWidget.prototype._createChild = function( nodeId, parentId, event ) {
            var self = this,
                client = self._client,
                node = client.getNode(nodeId);

            var selector = '#' + parentId.replace(/\//gm, "\\/");
            var cyNode = self._cy.$(selector);

            if (node.isAbstract()) {
                // do nothing!
            }
            else if (node.isMetaNode()) {
                var childCreationParams = {
                    parentId: parentId,
                    baseId: nodeId,
                };
                self.forceShowChildren( cyNode.id() );
                var newId = client.createChild(childCreationParams, 'Creating new child');
                self._updateDroppedChild( newId, event );
            }
            else {
                self.forceShowChildren( cyNode.id() );
                var params = {parentId: parentId};
                params[nodeId] = {};
                self._updateDroppedChild( parentId, event );
                client.startTransaction();
                client.copyMoreNodes(params);
                client.completeTransaction();
            }
        };

        HFSMVizWidget.prototype.showDropStatus = function () {
            var self = this;
            self.clearDropStatus();
            if (self._isDropping && self._hoveredNodeId && self._dropId) {
                var canDrop = self._canCreateChild( self._dropId, self._hoveredNodeId );
                var selector = '#' + self._hoveredNodeId.replace(/\//gm, "\\/");
                var node = self._cy.$( selector );
                if (node.length) {
                    var data = node.data();
                    if (canDrop)
                        data.ValidDrop = true;
                    else
                        data.InvalidDrop = true;
                    node.data( data );
                }
            }
        };

        HFSMVizWidget.prototype.clearDropStatus = function () {
            var self = this;
            var invalidDrops = self._cy.nodes('[InvalidDrop]');
            if (invalidDrops.length) {
                var data = invalidDrops.data();
                data.InvalidDrop = undefined;
                invalidDrops.data( data );
            }
            var validDrops = self._cy.nodes('[ValidDrop]');
            if (validDrops.length) {
                var data = validDrops.data();
                data.ValidDrop = undefined;
                validDrops.data( data );
            }
        };

        HFSMVizWidget.prototype._makeDroppable = function () {
            var self = this,
                desc;
            self._isDropping = false;
            self._right.addClass('drop-area');
            //self._div.append(self.__iconAssignNullPointer);

            dropTarget.makeDroppable(self._right, {
                over: function (event, dragInfo) {
                    self._isDropping = true;
                    self._dropId = (dragInfo && dragInfo[DROP_CONSTANTS.DRAG_ITEMS].length === 1) ?
                        dragInfo[DROP_CONSTANTS.DRAG_ITEMS][0] : null;
                },
                out: function (/*event, dragInfo*/) {
                    self._isDropping = false;
                    self._dropId = null;
                },
                drop: function (event, dragInfo) {
                    if (self._isValidDrop(event, dragInfo)) {
                        self._createChild(
                            dragInfo[DROP_CONSTANTS.DRAG_ITEMS][0],
                            self._hoveredNodeId,
                            event
                        );
                    }
                    self._isDropping = false;
                    self._dropId = null;
                }
            });
        };

        /* * * * * * * * Edge Creation Functions   * * * * * * * */

        HFSMVizWidget.prototype.draggedEdge = function( cySrc, cyDst, cyEdge ) {
            var self = this;
            var srcDesc = self.nodes[cySrc.id()];
            var dstDesc = self.nodes[cyDst.id()];
            var srcParentId = srcDesc.parentId;
            var newEdgePath = self.createNewEdge( srcParentId, srcDesc, dstDesc );
            cyEdge.remove();
        };

        HFSMVizWidget.prototype.createNewEdge = function( parentId, src, dst ) {
            var self = this;
            var client = self._client;
            // should be META:External Transition
            var edgeMetaId = '/615025579/318746662'; // need to not hardcode the edgeId
            var childCreationParams = {
                parentId: parentId,
                baseId: edgeMetaId,
            };

            client.startTransaction();

            var msg = 'Creating External Transition between ' + src.id + ' and '+dst.id;
            var newEdgePath = client.createChild( childCreationParams, msg);
            if (newEdgePath) {
                msg = 'Setting src pointer for ' + newEdgePath + ' to ' + src.id;
                client.setPointer( newEdgePath, 'src', src.id, msg );
                msg = 'Setting dst pointer for ' + newEdgePath + ' to ' + dst.id;
                client.setPointer( newEdgePath, 'dst', dst.id, msg );
            }

            client.completeTransaction();

            return newEdgePath;
        };

        HFSMVizWidget.prototype.isValidSource = function( desc ) {
            var self = this;
            if (desc.type == 'End State')
                return false;
            else if (desc.type == 'Internal Transition')
                return false;
            else if (desc.type == 'Deep History Pseudostate')
                return false;
            else if (desc.type == 'Shallow History Pseudostate')
                return false;
            else if (desc.type == 'State Machine')
                return false;
            else if (desc.type == 'Initial') {
                // if initial already has transition, don't allow more
                var initialEdges = self._simulator.getEdgesFromNode( desc.id );
                if (initialEdges.length)
                    return false;
            }
            return true;
        };

        HFSMVizWidget.prototype.validEdgeLoop = function( desc ) {
            var self = this;
            if (desc.type == 'Initial' ||
                desc.type == 'End State' ||
                desc.type == 'Internal Transition' ||
                desc.type == 'Deep History Pseudostate' ||
                desc.type == 'Shallow History Pseudostate' ||
                desc.type == 'Choice Pseudostate')
                return false;
            else
                return true;
        };

        HFSMVizWidget.prototype.validEdge = function( srcDesc, dstDesc ) {
            var self = this;
            var valid = true;
            var srcType = srcDesc.type;
            var dstType = dstDesc.type;
            if (dstType == 'Initial')
                valid = false;
            else if (dstType == 'State Machine')
                valid = false;
            else if (dstType == 'Internal Transition')
                valid = false;
            else if (srcType == 'Internal Transition')
                valid = false;
            else if (srcType == 'End State')
                valid = false;
            else if (srcType == 'Deep History Pseudostate')
                valid = false;
            else if (srcType == 'Shallow History Pseudostate')
                valid = false;
            else if (srcType == 'Initial') {
                if (dstType == 'Deep History Pseudostate' ||
                    dstType == 'Shallow History Pseudostate')
                    valid = false;
            }
            return valid;
        };

        /* * * * * * * * Visualizer event handlers * * * * * * * */

        HFSMVizWidget.prototype.onWidgetContainerResize = function (width, height) {
            this._cy.resize();
        };

        HFSMVizWidget.prototype.onNodeClick = function (/*id*/) {
            // This currently changes the active node to the given id and
            // this is overridden in the controller.
        };

        HFSMVizWidget.prototype.onBackgroundDblClick = function () {
        };

        /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
        HFSMVizWidget.prototype.destroy = function () {
        };

        HFSMVizWidget.prototype.onActivate = function () {
        };

        HFSMVizWidget.prototype.onDeactivate = function () {
        };

        return HFSMVizWidget;
    });
