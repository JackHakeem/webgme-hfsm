/*globals define, WebGMEGlobal*/
/*jshint browser: true*/

/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Thu May 11 2017 10:42:38 GMT-0700 (PDT).
 */

define([
    'text!./HFSM.html',
    './Dialog/Dialog',
    './Simulator/Choice',
    'bower/cytoscape/dist/cytoscape.min',
    'cytoscape-panzoom',
    'bower/cytoscape-cose-bilkent/cytoscape-cose-bilkent',
    'bower/mustache.js/mustache.min',
    'bower/blob-util/dist/blob-util.min',
    'text!./style2.css',
    'q',
    'css!bower/cytoscape-panzoom/cytoscape.js-panzoom.css',
    'css!./styles/HFSMVizWidget.css'], function (
	HFSMHtml,
        Dialog,
        Choice,
        cytoscape,
        cyPanZoom,
        coseBilkent,
        mustache,
        blobUtil,
        styleText,
	Q) {
	'use strict';

        cytoscape.use( cyPanZoom, $ );
        cytoscape.use( coseBilkent );
	
        var rootTypes = ['UMLStateDiagram'];

	var HFSMVizWidget,
            WIDGET_CLASS = 'h-f-s-m-viz';

	HFSMVizWidget = function (logger, container, client) {
            this._logger = logger.fork('Widget');

            this._el = container;

            this._client = client;

            // set widget class
            this._el.addClass(WIDGET_CLASS);
            this._el.append(HFSMHtml);
	    this._cy_container = this._el.find('#cy');

            this._initialize();

            this._logger.debug('ctor finished');
	};

	HFSMVizWidget.prototype._initialize = function () {
            var width = this._el.width(),
		height = this._el.height(),
		self = this;
	    
            this.nodes = {};
	    this.hiddenNodes = {};
	    this.dependencies = {
		'nodes': {},
		'edges': {}
	    };
	    this.waitingNodes = {};

	    this._cytoscape_options = {
		container: this._cy_container,
		style: styleText,
		// interaction options:
		minZoom: 1e-50,
		maxZoom: 1e50,
		zoomingEnabled: true,
		userZoomingEnabled: true,
		panningEnabled: true,
		userPanningEnabled: true,
		boxSelectionEnabled: false,
		selectionType: 'single',
		touchTapThreshold: 8,
		desktopTapThreshold: 4,
		autolock: false,
		autoungrabify: false,
		autounselectify: false,

		// rendering options:
		headless: false,
		styleEnabled: true,
		hideEdgesOnViewport: false,
		hideLabelsOnViewport: false,
		textureOnViewport: false,
		motionBlur: false,
		motionBlurOpacity: 0.2,
		wheelSensitivity: 1,
		pixelRatio: 'auto'	    
	    };

	    var self = this;

	    this._layout_options = {
		'name': 'cose-bilkent',
		// Called on `layoutready`
		ready: function () {
		},
		// Called on `layoutstop`
		stop: function () {
		},
		// Whether to fit the network view after when done
		fit: true,
		// Padding on fit
		padding: 10,
		// Whether to enable incremental mode
		randomize: true,
		// Node repulsion (non overlapping) multiplier
		nodeRepulsion: 5500, // 4500
		// Ideal edge (non nested) length
		idealEdgeLength: 100,   // 50
		// Divisor to compute edge forces
		edgeElasticity: 0.45,
		// Nesting factor (multiplier) to compute ideal edge length for nested edges
		nestingFactor: 0.1,
		// Gravity force (constant)
		gravity: 0.1,  // 0.25
		// Maximum number of iterations to perform
		numIter: 2500,
		// For enabling tiling
		tile: false,   // true
		// Type of layout animation. The option set is {'during', 'end', false}
		animate: 'end',
		// Represents the amount of the vertical space to put between the zero degree members during the tiling operation(can also be a function)
		tilingPaddingVertical: 10,
		// Represents the amount of the horizontal space to put between the zero degree members during the tiling operation(can also be a function)
		tilingPaddingHorizontal: 10,
		// Gravity range (constant) for compounds
		gravityRangeCompound: 1.5,
		// Gravity force (constant) for compounds
		gravityCompound: 1.0,
		// Gravity range (constant)
		gravityRange: 3.8
	    };
	    this._cytoscape_options.layout = self._layout_options;
	    this._cy = cytoscape(self._cytoscape_options);

	    var layoutPadding = 50;
	    var layoutDuration = 500;

            // PAN ZOOM WIDGET:

            // the default values of each option are outlined below:
            var panZoom_defaults = {
                zoomFactor: 0.05, // zoom factor per zoom tick
                zoomDelay: 45, // how many ms between zoom ticks
                minZoom: 0.1, // min zoom level
                maxZoom: 10, // max zoom level
                fitPadding: 50, // padding when fitting
                panSpeed: 10, // how many ms in between pan ticks
                panDistance: 10, // max pan distance per tick
                panDragAreaSize: 75, // the length of the pan drag box in which the vector for panning is calculated (bigger = finer control of pan speed and direction)
                panMinPercentSpeed: 0.25, // the slowest speed we can pan by (as a percent of panSpeed)
                panInactiveArea: 8, // radius of inactive area in pan drag box
                panIndicatorMinOpacity: 0.5, // min opacity of pan indicator (the draggable nib); scales from this to 1.0
                zoomOnly: false, // a minimal version of the ui only with zooming (useful on systems with bad mousewheel resolution)
                fitSelector: undefined, // selector of elements to fit
                animateOnFit: function(){ // whether to animate on fit
                    return false;
                },
                fitAnimationDuration: 1000, // duration of animation on fit

                // icon class names
                sliderHandleIcon: 'fa fa-minus',
                zoomInIcon: 'fa fa-plus',
                zoomOutIcon: 'fa fa-minus',
                resetIcon: 'fa fa-expand'
            };

            self._cy.panzoom( panZoom_defaults );
	    
	    function highlight( node ) {
		self.highlight(node);
	    }

	    function clear(){
		self.clear();
	    }

            // USED FOR NODE SELECTION AND MULTI-SELECTION

            self._selectedNodes = [];
            self._cy.on('select', 'node, edge', function(e){
                var node = this;
                var id = node.id();
                if (id) {
                    if (self._selectedNodes.indexOf(id) == -1) {
                        self._selectedNodes.push(id);
                        WebGMEGlobal.State.registerActiveSelection(self._selectedNodes.slice(0));
                    }
                }
                highlight( node );
            });

            self._cy.on('unselect', 'node, edge', function(e){
                var node = this;
                var id = node.id();
                if (id) {
                    self._selectedNodes = self._selectedNodes.filter(function(n) {
                        return id != n;
                    });
                    //self._selectedNodes = [];
                    WebGMEGlobal.State.registerActiveSelection(self._selectedNodes.slice(0));
                }
                clear();
            });

            // USED FOR KNOWING WHEN NODES ARE MOVED
            self._webGME_to_cy_scale = 1;
            self._grabbedNode = null;
            self._cy.on('grabon', 'node', function(e) {
                var node = this;
                if (node.id()) {
                    self._grabbedNode = node;
                }
            });

            self._cy.on('free', 'node', function(e) {
                self._grabbedNode = null;
            });

            self._debouncedSaveNodePositions = _.debounce(self.saveNodePositions.bind(self), 500);
            self._unsavedNodePositions = {};
            self._cy.on('position', 'node', function(e) {
                var node = this;
                if (rootTypes.indexOf(node.data('type')) == -1) {
                    var pos = self.cyPosToGmePos( node );
                    self._unsavedNodePositions[node.id()] = pos;
                    self._debouncedSaveNodePositions()
                }
            });
	};

        /* * * * * * * * Display Functions  * * * * * * * */

        function download(filename, text) {
            var element = document.createElement('a');
            var imgData = text.split(',')[1]; // after the comma is the actual image data

            blobUtil.base64StringToBlob( imgData.toString() ).then(function(blob) {
                var blobURL = blobUtil.createObjectURL(blob);

                element.setAttribute('href', blobURL);
                element.setAttribute('download', filename);
                element.style.display = 'none';

                document.body.appendChild(element);

                element.click();

                document.body.removeChild(element);
            }).catch(function(err) {
                console.log('Couldnt make blob from image!');
                console.log(err);
            });
        }

        HFSMVizWidget.prototype.onPanningClicked = function() {
            var self = this;
            self._cy.userPanningEnabled(true);
            self._cy.boxSelectionEnabled(false);
            self._cy.autoungrabify(false);
        };

        HFSMVizWidget.prototype.onBoxSelectClicked = function() {
            var self = this;
            self._cy.userPanningEnabled(false);
            self._cy.boxSelectionEnabled(true);
            self._cy.autoungrabify(true);
        };

        HFSMVizWidget.prototype._addSplitPanelToolbarBtns = function(toolbarEl) {
            var self = this;

            var layoutPadding = 50;
            var layoutDuration = 500;

            // BUTTON EVENT HANDLERS

            var printEl = [
                '<span id="print" class="split-panel-toolbar-btn fa fa-print">',
                '</span>',
            ].join('\n');

            var moveEl = [
                '<span id="pan" class="split-panel-toolbar-btn fa fa-arrows">',
                '</span>',
            ].join('\n');

            var selectEl = [
                '<span id="select" class="split-panel-toolbar-btn fa fa-crop">',
                '</span>',
            ].join('\n');

            var zoomEl = [
                '<span id="zoom" class="split-panel-toolbar-btn fa fa-home">',
                '</span>',
            ].join('\n');

            var layoutEl = [
                '<span id="layout" class="split-panel-toolbar-btn fa fa-random">',
                '</span>',
            ].join('\n');

            toolbarEl.append(printEl);
            //toolbarEl.append(moveEl);
            //toolbarEl.append(selectEl);
            toolbarEl.append(zoomEl);
            toolbarEl.append(layoutEl);

            toolbarEl.find('#print').on('click', function(){
                var png = self._cy.png({
                    full: true,
                    scale: 6,
                    bg: 'white'
                });
                download( self.HFSMName + '-HFSM.png', png );
            });

            toolbarEl.find('#pan').on('click', function() {
                self.onPanningClicked();
            });
            
            toolbarEl.find('#select').on('click', function() {
                self.onBoxSelectClicked();
            });
            
            toolbarEl.find('#zoom').on('click', function(){
                self._cy.animate({
                    fit: {
                        eles: self._cy.elements(),
                        padding: layoutPadding
                    },
                    duration: layoutDuration
                });
            });

            toolbarEl.find('#layout').on('click', function(){
                // ask if they really want to randomize the layout
                var choice = new Choice();
                var choices = [
                    'Yes, run cose-bilkent layout.',
                    'No, do not change any positions'
                ];
                choice.initialize( choices, "Really change the layout?" );
                choice.show();
                return choice.waitForChoice()
                    .then(function(choice) {
                        if (choice == choices[0])
                            self.reLayout();
                    });
            });
        };

        HFSMVizWidget.prototype.highlight = function(node) {
            var self = this;
            node.select();
        };

        HFSMVizWidget.prototype.clear = function() {
            var self = this;
            self._cy.$(':selected').unselect();
        };

        /* * * * * * * * Node Position Functions  * * * * * * * */

        HFSMVizWidget.prototype.getCyTopLeft = function(cyNode) {
            
        };

        HFSMVizWidget.prototype.gmePosToCyPos = function(gmePos) {
            var self = this;
            var cyPos = gmePos;
            /*
            cyPos.x *= self._webGME_to_cy_scale;
            cyPos.y *= self._webGME_to_cy_scale;
            */
            return cyPos;
        };

        HFSMVizWidget.prototype.cyPosToGmePos = function(cyNode) {
            var self = this;
            var cyPos = cyNode.position();
            var gmePos = cyPos;
            /*
            gmePos.x /= self._webGME_to_cy_scale;
            gmePos.y /= self._webGME_to_cy_scale;
            */
            return gmePos;
        };

        HFSMVizWidget.prototype.needToUpdatePosition = function(pos1, pos2) {
            var dx = Math.abs(pos1.x - pos2.x);
            var dy = Math.abs(pos1.y - pos2.y);
            var dyThresh = 0.1;
            var dxThresh = 0.1;
            return (dy > dyThresh || dx > dxThresh);
        };

        HFSMVizWidget.prototype.saveNodePositions = function() {
            var self = this;
            var keys = Object.keys(self._unsavedNodePositions);

            self._client.startTransaction();

            keys.map(function(k) {
                var id = k;
                var pos = self._unsavedNodePositions[id];
                if (self.nodes[id]) {
                    var savedPos = self.nodes[id].position;
                    if (self.needToUpdatePosition(pos, savedPos))
                        self._client.setRegistry(id, 'position', pos);
                }
            });

            self._client.completeTransaction();

            self._unsavedNodePositions = {};
        };

        /* * * * * * * * Graph Creation Functions  * * * * * * * */

	HFSMVizWidget.prototype.checkDependencies = function(desc) {
	    var self = this;
	    // dependencies will always be either parentId (nodes & edges) or connection (edges)
	    var deps = [];
	    if (desc.parentId && !self.nodes[desc.parentId]) {
		deps.push(desc.parentId);
	    }
	    if (desc.isConnection) {
		if (!self.nodes[desc.src])
		    deps.push(desc.src);
		if (!self.nodes[desc.dst])
		    deps.push(desc.dst);
	    }
	    var depsMet = (deps.length == 0);
	    if (!depsMet) {
		if (desc.isConnection)
		    self.dependencies.edges[desc.id] = deps;
		else 
		    self.dependencies.nodes[desc.id] = deps;
		self.waitingNodes[desc.id] = desc;
		if (self.nodes[desc.id])
		    delete self.nodes[desc.id];
	    }
	    return depsMet;
	};

	HFSMVizWidget.prototype.updateDependencies = function() {
	    var self = this;
	    var nodePaths = Object.keys(self.dependencies.nodes);
	    var edgePaths = Object.keys(self.dependencies.edges);
	    // create any nodes whose depenencies are fulfilled now
	    nodePaths.map(function(nodePath) {
		var depPaths = self.dependencies.nodes[nodePath];
		if (depPaths && depPaths.length > 0) {
		    depPaths = depPaths.filter(function(objPath) { return self.nodes[objPath] == undefined; });
		    if (!depPaths.length) {
			var desc = self.waitingNodes[nodePath];
			self.waitingNodes[nodePath] = undefined;
			self.dependencies.nodes[nodePath] = undefined;
			self.createNode(desc);
		    }
		    else {
			self.dependencies.nodes[nodePath] = depPaths;
		    }
		}
		else {
		    self.dependencies.nodes[nodePath] = undefined;
		}
	    });
	    // Create any edges whose dependencies are fulfilled now
	    edgePaths.map(function(edgePath) {
		var depPaths = self.dependencies.edges[edgePath];
		if (depPaths && depPaths.length > 0) {
		    depPaths = depPaths.filter(function(objPath) { return self.nodes[objPath] == undefined; });
		    if (!depPaths.length) {
			var connDesc = self.waitingNodes[edgePath];
			self.waitingNodes[edgePath] = undefined;
			self.dependencies.edges[edgePath] = undefined;
			self.createEdge(connDesc);
		    }
		    else {
			self.dependencies.edges[edgePath] = depPaths;
		    }
		}
		else {
		    self.dependencies.edges[edgePath] = undefined;
		}
	    });
	};

        HFSMVizWidget.prototype.reLayout = function() {
            var self = this;
            var layout = self._cy.layout(self._layout_options);
            layout.run();
            //self._cy.nodes().qtip({ content: 'hi', position: { my: 'top center', at: 'bottom center' } })
        };

	HFSMVizWidget.prototype.getDescData = function(desc) {
	    var self = this;
	    var data = {};
	    if (desc.isConnection) {
		var from = self.nodes[desc.src];
		var to = self.nodes[desc.dst];
		if (from && to) {
		    data = {
			id: desc.id,
			type: desc.type,
			interaction: desc.type,
			source: from.id,
			target: to.id,
			name: desc.name,
			// source-label
			// target-label
			label: desc.text
		    };
		}
	    }
	    else {
		data = {
		    id: desc.id,
		    parent: desc.parentId,
		    type: desc.type,
		    NodeType: desc.type,
		    name: desc.name,
		    label: desc.name,
		    orgPos: null
		};
	    }
	    return data;
	};

	HFSMVizWidget.prototype.createEdge = function(desc) {
	    var self = this;
	    var data = self.getDescData(desc);
	    if (data) {
		self._cy.add({
		    group: 'edges',
		    data: data
		});
		self.nodes[desc.id] = desc;
		self.updateDependencies();
	    }
	};

	HFSMVizWidget.prototype.createNode = function(desc) {
	    var self = this;
	    var data = self.getDescData(desc);
	    var node = {
		group: 'nodes',
		data: data
	    };

            var parentCyNode = null;
            var parentPos = null;
            if (desc.parentId) {
                var parentIdTag = desc.parentId.replace(/\//gm, "\\/");
                var parentCyNode = self._cy.$('#'+parentIdTag);
            }
            if (parentCyNode) {
                parentPos = parentCyNode.position();
            }

            var n = self._cy.add(node);

            if (parentCyNode && parentPos) {
                parentCyNode.position( parentPos );
                //n.position( parentPos );
                var pos = self.gmePosToCyPos( desc.position );
                /*
                var w = parentCyNode.width();
                var h = parentCyNode.height();
                pos.x -= w;
                pos.y -= h;
                */
                //console.log('making node at position: '+pos.x+','+pos.y);
                //n.relativePosition( pos );
                n.position( pos );
            }

	    self.nodes[desc.id] = desc;
	    self.updateDependencies();
	};
	
	// Adding/Removing/Updating items
	HFSMVizWidget.prototype.addNode = function (desc) {
	    var self = this;
            if (desc) {
		var depsMet = self.checkDependencies(desc);
		// Add node to a table of nodes
		if (desc.isConnection) {  // if this is an edge
		    if (depsMet) { // ready to make edge
			self.createEdge(desc);
		    }
		}
		else {
		    if (depsMet) { // ready to make node
			self.createNode(desc);
		    }
		}
	    }
	};

	HFSMVizWidget.prototype.removeNode = function (gmeId) {
	    // TODO: need to have this take into account hidden nodes!
	    var self = this;
	    var idTag = gmeId.replace(/\//gm, "\\/");
            var desc = self.nodes[gmeId];
	    if (desc) {
		delete self.nodes[gmeId];
		if (!desc.isConnection) {
		    //self._cy.filter('edge[source = "'+idTag+'"], edge[dest = "'+idTag+'"]'));
		    self._cy.$('#'+idTag).neighborhood(function(obj) {
			var ele = this;
			if (ele.isEdge()) {
			    var edgeId = ele.data( 'id' );
			    var edgeDesc = self.nodes[edgeId];
			    self.checkDependencies(edgeDesc);
			}
		    });
		}
		self._cy.remove("#" + idTag);
		self.updateDependencies();
	    }
	};

	HFSMVizWidget.prototype.updateNode = function (desc) {
	    // TODO: need to have this take into account hidden nodes!
            if (desc) {
		if (this.nodes[desc.id]) {
		    var idTag = desc.id.replace(/\//gm, "\\/");
		    if (desc.isConnection) {
			this._cy.remove('#' + idTag);
			this.createEdge(desc);
		    }
		    else {
			this._cy.$('#'+idTag).data( this.getDescData(desc) );
		    }
		}
            }
	};

        /* * * * * * * * Visualizer event handlers * * * * * * * */

        HFSMVizWidget.prototype.onWidgetContainerResize = function (width, height) {
            this._cy.resize();
        };

	HFSMVizWidget.prototype.onNodeClick = function (/*id*/) {
            // This currently changes the active node to the given id and
            // this is overridden in the controller.
	};

	HFSMVizWidget.prototype.onBackgroundDblClick = function () {
	};

	/* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
	HFSMVizWidget.prototype.destroy = function () {
	};

	HFSMVizWidget.prototype.onActivate = function () {
	};

	HFSMVizWidget.prototype.onDeactivate = function () {
	};

	return HFSMVizWidget;
    });
