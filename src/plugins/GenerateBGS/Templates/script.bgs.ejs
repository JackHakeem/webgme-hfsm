import "constants.bgs"
import "globals.bgs"
# Import user libraries here (if any)
<%
if (model.Library_list) {
  model.Library_list.map(function(library) {
-%>
import "<%- library.name %>.bgs"
<%
  });
}
-%>

const state_timer_handle = 0

dim changeState
dim state(64)
<%
states.map(function(state) {
-%>
dim <%- state.stateName %>(<%- state.path.length %>)
<%
});
-%>

# The system_boot handler deals with all initialization needed.
event system_boot(major, minor, patch, build, ll_version, protocol_version, hw)
  # user initialization code:
  #
  # START USER CODE
  #
<%- model.system_boot %>
  #
  # END USER CODE
  #
  # generated initialization code for the state machine:
  changeState = 0
  # STATE::<%- model.initState.name %>
  state(0:<%- model.initState.path.length %>) = "<%- model.initState.path %>"
<%
states.map(function(state) {
-%>
  <%- state.stateName %>(0:<%- state.path.length %>) = "<%- state.path %>"
<%
});
-%>
end

# The timer handles all the state function code and state transition
#  code
event hardware_soft_timer(handle)
  changeState = 0
  # Generated code to execute state transitions and state functions:
<%
if (model.State_list) {
  model.State_list.map(function(state) {
-%>
<%- state.timerFunc %>
<%
  });
}
-%>
end

# The interrupt routine handles all conversion from input interrupts
#  to state variables for state transitions
event hardware_io_port_status(timestamp, port, irq, state_io)
  # user code to handle the interrupts and convert them to state
  #  variables:
  #
  # START USER CODE
  #
<%- model.hardware_io_port_status %>
  #
  # END USER CODE
  #

  changeState = 0
  # Generated code to perform needed state transitions:
<%
if (model.State_list) {
  model.State_list.map(function(state) {
-%>
<%- state.irqFunc %>
<%
  });
}
-%>
end
<%
if (model.Event_list) {
  model.Event_list.map(function(event) {
-%>

<%- event.function %>
<%
  });
}
-%>
